<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.313">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Tomas Polakovic">
<meta name="dcterms.date" content="2019-10-03">
<meta name="description" content="Our first jump into quantum mechanics.">

<title>A Bit Correlated - Computational Physics for the Masses Part 1: Spinning and Sloshing in Atoms</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">A Bit Correlated</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"><i class="bi bi-rss" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/tpolakovic/tpolakovic.github.io"><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Computational Physics for the Masses Part 1: Spinning and Sloshing in Atoms</h1>
                  <div>
        <div class="description">
          Our first jump into quantum mechanics.
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Julia</div>
                <div class="quarto-category">Quantum mechanics</div>
                <div class="quarto-category">Basics</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Tomas Polakovic </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">October 3, 2019</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>In the <a href="comp-phys-mass-0.html">zeroth part</a>, I mentioned that we will do some almost professional science stuff. But to <a href="http://i.imgur.com/rCr9A.png">draw an owl</a>, you need to start with circles, which is something we’ll do today. I’ll show you what does it actually mean to solve a quantum-mechanical problem and what are the most basic mathematical tools to do it.</p>
<p>To demonstrate the use of these tools, I need some physical example. There are a few choices, the most common one being the particle in square potential well. A system like that is nice because people are intuitively more familiar with problems in real space, but there are some nuances that get swept under the rug in introductory materials and don’t become really obvious in a calculus-based approach. However, computers are generally bad at calculus and <em>really</em> good at algebra, so we’ll rely more on the <a href="https://en.wikipedia.org/wiki/Matrix_mechanics">matrix formulation of quantum mechanics</a>, where the finer details of real-space representation and consequences of having a finite amount of memory would force me to feed you too much information in one sitting. Fortunately, there are other simple examples that work without silent assumptions and demonstrate the basics just as well - systems with finite, small amount of possible states like particle spin and angular momentum.</p>
<hr>
<section id="touching-bases-with-angular-momentum-and-spin" class="level3">
<h3 class="anchored" data-anchor-id="touching-bases-with-angular-momentum-and-spin">Touching base(s) with Angular Momentum and Spin</h3>
<p>The first problem we’ll attempt to solve is that of energies of electrons in presence of magnetic fields. It’s not necessarily the most general or interesting problem, but the idea of measuring (changes of) energy states of things is <a href="https://en.wikipedia.org/wiki/Spectroscopy">very popular</a> in physics. To do that, we should talk a bit about angular momentum in quantum mechanics. We can start with classical mechanics first, where angular momentum is simply defined as</p>
<p><span class="math display">\[ \vec{L} = \vec{r} \times \vec{p}. \]</span></p>
<p>If we know the momentum and position of an object relative to some reference point, it’s easy to know it’s angular momentum. Just to get classical physics out of the way, I’ll get a little bit ahead of myself and also point out that angular momentum can be shown to be <a href="https://en.wikipedia.org/wiki/Magnetic_moment#Relation_to_angular_momentum">related</a> to magnetic moment <span class="math inline">\(\vec{m}\)</span> which describes the strength of a magnetic dipole. In classical physics the relationship between these two is</p>
<p><span class="math display">\[ \vec{m} = \gamma \vec{L}, \]</span></p>
<p>where <span class="math inline">\(\gamma\)</span> is the <a href="https://en.wikipedia.org/wiki/Gyromagnetic_ratio">gyromagnetic ratio</a>. If you want a hand-wavy explanation for why are these two related, consider how does a magnetic dipole get produced: From a circulating current. So a massive charge that flies around in circles will have angular momentum because…ehm…it has mass and flies around in circles, and it also produces a magnetic dipole because the circling around of charge forms a current loop.</p>
<p>However, we want to deal with quantum mechanics, so we need operators that will act on a wave function (or a state).</p>
<p><em>What follows is not that hard to derive (it’s usually done in the first quantum mechanics class in undergrad, so you don’t need more than first-year college math) but it’s tedious, especially if you’re allergic to spherical coordinates. To get started here, we need to know only a few algebraic properties of the operators which I will spell out in the next few paragraphs. If this is new to you, your two options are to either take my word for it (not recommended), or do a quick Google search for angular momentum in quantum mechanics (first good hit for me was <a href="http://physics.ucc.ie/apeer/PY3102/Angular_momentum.pdf">this</a>) and at least skim through what you find. I’ll wait.</em></p>
<p>Done? Good. So, the <a href="https://en.wikipedia.org/wiki/Angular_momentum_operator">angular momentum operator</a> (in <a href="https://en.wikipedia.org/wiki/Position_and_momentum_space">position representation</a>) is</p>
<p><span class="math display">\[ \hat{\mathbf{L}} = -i \hbar (\vec{r} \times \nabla), \]</span></p>
<p>where <span class="math inline">\(\nabla\)</span> is the <a href="https://en.wikipedia.org/wiki/Del">nabla</a> operator. In this case (we represent the wavefunctions in real-space), the momentum operator is <span class="math inline">\(-i\hbar\nabla\)</span> (position derivative of the wavefunction with some pre-factors) and the position operator is just multiplication by the position, so the operator <span class="math inline">\(\hat{\mathbf{L}}\)</span> follows relatively closely it’s classical counterpart. But that’s where the similarities end. In classical mechanics, nothing is stopping you from knowing all the components of the angular momentum <span class="math inline">\(\vec{L} = \left( L_x, L_y, L_z \right)\)</span> but in quantum mechanics, the <a href="https://en.wikipedia.org/wiki/Uncertainty_principle">uncertainty principle</a> poops on our parade.</p>
<p><a href="https://quantummechanics.ucsd.edu/ph130a/130_notes/node188.html">It can be shown</a> that only commuting properties can be measured at the same time with arbitrarily small uncertainty. If we calculate the commutator <span class="math inline">\(\left[ \hat{X}, \hat{Y} \right] = \hat{X}\hat{Y} - \hat{Y}\hat{X}\)</span> of the angular momentum component operators, we’ll see that individual components don’t fall into this category:</p>
<p><span class="math display">\[ \left[ \hat{L}_l, \hat{L}_m \right] =i\hbar \sum_n \varepsilon_{lmn}\hat{L}_n, \]</span></p>
<p>where <span class="math inline">\(l,m,n = \{x,y,z\}\)</span> and <span class="math inline">\(\varepsilon_{lmn}\)</span> is the <a href="https://en.wikipedia.org/wiki/Levi-Civita_symbol">Levi-Civita symbol</a> (proof is left as an excercise to the reader). This means that you cannot measure more than one component at a time (or rather, you can but it will be subject to quantum-mechanical uncertainty). Imagine it as the angular momentum vector rotating along an axis, drawing out a cone surface while doing so. You can determine the cone side length (the magnitude) and the cone angle/height (the projection along that axis). The uncertainty principle forbids you to know where on the cone surface does the angular momentum lie.</p>
<p>The other important ingredient to what follows is the magnitude of angular momentum <span class="math inline">\(\hat{L}^2 = \hat{L}_x^2 + \hat{L}_y^2 + \hat{L}_z^2\)</span>, which fortunately does commute with the components:</p>
<p><span class="math display">\[\left[\hat{L}^2, \hat{L}_x \right] = \left[\hat{L}^2, \hat{L}_y \right] = \left[\hat{L}^2, \hat{L}_z \right] = 0.\]</span></p>
<p>Proof of this one is <a href="https://en.wikipedia.org/wiki/Proof_by_intimidation">obvious</a> if you do the commutation relations for individual components. As one would expect from <em>quantum</em> mechanics, the angular momentum is quantized and has corresponding quantum numbers for magnitude <span class="math inline">\(l \in \{ 0, \frac{1}{2}, 1, \frac{3}{2}, 2,\ldots \}\)</span> and projection along one axis (conventionally, the z-axis) <span class="math inline">\(m \in \{ -l, -l+1,\ldots,l-1, l \}\)</span>.</p>
<p>Now we can finally get to actual code. First, I’ll import the libraries we’ll use today: Plots, LinearAlgebra, DifferentialEquations and LaTeXStrings. You’ll have to install most of them before use and there are two ways to do that: If you’re in a Julia <a href="https://en.wikipedia.org/wiki/Read–eval–print_loop">REPL</a>, you can just press the <code>]</code> key, which will bring you into the package management mode and just do, for example, <code>add Plots</code> (ctrl-c to exit the mode). If you’re in a Jupyter notebook or run an older version of Julia (I think &lt;0.7), first enter <code>using Pkg</code> and then <code>Pkg.add("Plots")</code> (this method works also in the REPL).</p>
<p>Names of the libraries are self-descriptive, so I won’t waste time on describing what’s in them right now, but there’s something I want to warn you about: Julia is <a href="https://en.wikipedia.org/wiki/Just-in-time_compilation">JIT</a> compiled and the first import of big libraries can take some time as the packages are pre-compiling certain parts to save you time during runtime. Don’t panic, if you were to use it in a big-boy piece of software where performance becomes important, the initial loading time amortizes as it’s done only once.</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">Plots</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">LinearAlgebra</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">DifferentialEquations</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">LaTeXStrings</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Those of you, who read the zeroth part of this series know that we have to chose a basis to do any numerical calculations. In principle, any complete orthonormal basis would suffice, but we can make the problem much simpler by picking a basis that reduces the amount of work we do. Our current endgame is to solve the Schrödinger equation which amounts to diagonalizing the Hamiltonian that will consist of a bunch of angular momentum (or spin) operators, so it’s convenient to use the joint eigenstates of the <span class="math inline">\(\hat{L}^2\)</span> and <span class="math inline">\(\hat{L}_z\)</span> operators <span class="math inline">\(\{ \left|l,m\right&gt; \}_{m=-l}^l\)</span>. For the rest of the discussion, I’ll switch the “name” of the operator from <span class="math inline">\(L\)</span> to <span class="math inline">\(S\)</span> for reasons that will become obvious soon, i.e.&nbsp;the states become <span class="math inline">\(\left|s,m\right&gt;\)</span>.</p>
<p>Now, to define an operator means to define what it does to a state. The case of the <span class="math inline">\(\hat{S}^2\)</span> and <span class="math inline">\(\hat{S}_z\)</span> operators is easy because we used their eigenstates as the basis:</p>
<p><span class="math display">\[ \hat{S}^2 \left| s, m \right&gt; = s(s+1) \left| s, m \right&gt;, \]</span> <span class="math display">\[ \hat{S}_z \left| s, m \right&gt; = m \left| s, m \right&gt;. \]</span></p>
<p>To define the <span class="math inline">\(\hat{S_x}\)</span> and <span class="math inline">\(\hat{S_y}\)</span> operators, we use <a href="https://en.wikipedia.org/wiki/Ladder_operator#Angular_momentum">raising and lowering operators</a> which I’ll call <span class="math inline">\(S_+\)</span> and <span class="math inline">\(S_-\)</span>, respectively.</p>
<p><span class="math display">\[ \hat{S}_+ \left| s, m \right&gt; = \sqrt{s(s+1) - m(m+1)} \left| s, m+1 \right&gt;, \]</span> <span class="math display">\[ \hat{S}_- \left| s, m \right&gt; = \sqrt{s(s+1) - m(m-1)} \left| s, m-1 \right&gt;. \]</span></p>
<p>These operators are slightly different because they’re not <a href="https://en.wikipedia.org/wiki/Self-adjoint_operator">Hermitian</a> (they are not their own complex conjugates). As a consequence, they don’t have real eigenvalues and don’t correspond to physical observables. What they do is change the projection of spin: if we take a state with magnitude s and z-projection m and apply the operator <span class="math inline">\(\hat{S}_+\)</span>, it “tilts” towards the axis and becomes a state with projection m+1. We can then use the equality <span class="math inline">\(\hat{S}_{\pm} = \hat{S}_x \pm i\hat{S}_y\)</span> to define the last two component operators</p>
<p><span class="math display">\[ \hat{S}_x \left| s, m \right&gt; = \frac{\hat{S}_+ + \hat{S}_-}{2} \left| s, m \right&gt;, \]</span> <span class="math display">\[ \hat{S}_y \left| s, m \right&gt; = \frac{\hat{S}_+ - \hat{S}_-}{2i} \left| s, m \right&gt;. \]</span></p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">s₊</span>(s)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="fu">mod</span>(s, <span class="fl">1</span><span class="op">/</span><span class="fl">2</span>) <span class="op">==</span> <span class="fl">0</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="fu">diagm</span>(<span class="fl">1</span> <span class="op">=&gt;</span>[<span class="fu">sqrt</span>(<span class="fu">s*</span>(s<span class="op">+</span><span class="fl">1</span>) <span class="op">-</span> <span class="fu">m*</span>(m<span class="op">+</span><span class="fl">1</span>)) for m <span class="kw">in</span> (s<span class="op">-</span><span class="fl">1</span>)<span class="op">:</span>(<span class="op">-</span><span class="fl">1</span>)<span class="op">:</span>(<span class="op">-</span>s)])</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="fu">throw</span>(<span class="fu">DomainError</span>(s, <span class="st">"spin number must be a integer multiple of 1/2"</span>))</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">s₋</span>(s)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">copy</span>(<span class="fu">transpose</span>(<span class="fu">s₊</span>(s)))</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">sx</span>(s)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    (<span class="fu">s₊</span>(s) <span class="op">+</span> <span class="fu">s₋</span>(s)) <span class="op">/</span> <span class="fl">2.0</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">sy</span>(s)</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    (<span class="fu">s₊</span>(s) <span class="op">-</span> <span class="fu">s₋</span>(s)) <span class="op">/</span> <span class="fl">2.0im</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">sz</span>(s)</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="fu">mod</span>(s, <span class="fl">1</span><span class="op">/</span><span class="fl">2</span>) <span class="op">==</span> <span class="fl">0</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>        <span class="fu">diagm</span>(<span class="fl">0</span> <span class="op">=&gt;</span> (s)<span class="op">:</span>(<span class="op">-</span><span class="fl">1</span>)<span class="op">:</span>(<span class="op">-</span>s))</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>        <span class="fu">throw</span>(<span class="fu">DomainError</span>(s, <span class="st">"spin number must be a integer multiple of 1/2"</span>))</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">sid</span>(s)</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="fu">mod</span>(s, <span class="fl">1</span><span class="op">/</span><span class="fl">2</span>) <span class="op">==</span> <span class="fl">0</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>        n <span class="op">=</span> <span class="fu">Int</span>(<span class="fu">round</span>(<span class="fl">2</span><span class="op">*</span>s<span class="op">+</span><span class="fl">1</span>))</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>        <span class="fu">Matrix</span>(I, n, n)</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>        <span class="fu">throw</span>(<span class="fu">DomainError</span>(s, <span class="st">"spin number must be a integer multiple of 1/2"</span>))</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The implementation of the code is pretty straight-forward once you properly digest what is written above it. For a given spin (or angular momentum) magnitude s, there is a set of 2s+1 basis vectors with 1 in their corresponding m-component and 0 everywhere else, i.e.&nbsp;<span class="math inline">\(\left| s, s \right&gt; = (1, 0, 0, ...)\)</span>, <span class="math inline">\(\left| s, s-1 \right&gt; = (0, 1, 0, ...)\)</span>, etc. The operators are just matrices that multiply the state vectors, as prescribed by the formulas. This is perhaps best demonstrated by a concrete example of, say, the raising operator for a spin-1 state which acts as <span class="math inline">\(\hat{S}_+ \left| 1, -1 \right&gt; = \sqrt{2} \left| 1, 0 \right&gt;\)</span>, <span class="math inline">\(\hat{S}_+ \left| 1, 0 \right&gt; = \sqrt{2} \left| 1, 1 \right&gt;\)</span> and <span class="math inline">\(\hat{S}_+ \left| 1, 1 \right&gt; = 0\)</span>:</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">s₊</span>(<span class="fl">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="3">
<pre><code>3×3 Array{Float64,2}:
 0.0  1.41421  0.0    
 0.0  0.0      1.41421
 0.0  0.0      0.0    </code></pre>
</div>
</div>
<p>Code-wise, there’s not much to comment on because most of the operator-generating functions use the <code>s₊</code> function. We first make sure that the input is a valid quantum of angular momentum (which in units of <span class="math inline">\(\hbar\)</span> is an integer multiple of 1/2) and then use it to generate a off-diagonal matrix using the line <code>diagm(1 =&gt;[sqrt(s*(s+1) - m*(m+1)) for m in (s-1):(-1):(-s)])</code>.</p>
<p>To disassemble this line, let’s first look at <code>[sqrt(s*(s+1) - m*(m+1)) for m in (s-1):(-1):(-s)]</code> which uses <a href="https://en.wikibooks.org/wiki/Introducing_Julia/Controlling_the_flow#Comprehensions">list comprehensions</a> that are familiar to anyone who used Python before: an expression <code>[f(x) fox x in start:step:stop]</code> will generate a vector with components <code>f(x)</code> with x going from <code>start</code> to <code>stop</code> by <code>step</code>, e.g.</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>[<span class="fu">abs</span>(x) for x <span class="kw">in</span> <span class="op">-</span><span class="fl">5</span><span class="op">:</span><span class="fl">2</span><span class="op">:</span><span class="fl">5</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<pre><code>6-element Array{Int64,1}:
 5
 3
 1
 1
 3
 5</code></pre>
</div>
</div>
<p>The other function is <code>diagm(n =&gt; v)</code> which generates a diagonal matrix with the vector <code>v</code> on the<code>n</code>-th diagonal. The last function<code>sid</code> is the identity function. I put it there in anticipation of what will happen in a moment.</p>
<p><em>This might a good time to demonstrate how to use the Julia’s documentation feature, where anywhere in the REPL or in a Jupyter notebook, you can just do <code>?expr</code> to get documentation for the given <code>expr</code>, like this:</em></p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>?diagm</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>search: diagm StochasticDiffEqAlgorithm OrdinaryDiffEqAlgorithm
</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="5">
<pre><code>diagm(kv::Pair{&lt;:Integer,&lt;:AbstractVector}...)</code></pre>
<p>Construct a square matrix from <code>Pair</code>s of diagonals and vectors. Vector <code>kv.second</code> will be placed on the <code>kv.first</code> diagonal. <code>diagm</code> constructs a full matrix; if you want storage-efficient versions with fast arithmetic, see <a href="@ref"><code>Diagonal</code></a>, <a href="@ref"><code>Bidiagonal</code></a> <a href="@ref"><code>Tridiagonal</code></a> and <a href="@ref"><code>SymTridiagonal</code></a>.</p>
<section id="examples" class="level1">
<h1>Examples</h1>
<pre class="jldoctest"><code>julia&gt; diagm(1 =&gt; [1,2,3])
4×4 Array{Int64,2}:
 0  1  0  0
 0  0  2  0
 0  0  0  3
 0  0  0  0

julia&gt; diagm(1 =&gt; [1,2,3], -1 =&gt; [4,5])
4×4 Array{Int64,2}:
 0  1  0  0
 4  0  2  0
 0  5  0  3
 0  0  0  0</code></pre>
<hr>
<pre><code>diagm(v::AbstractVector)</code></pre>
<p>Construct a square matrix with elements of the vector as diagonal elements.</p>
</section>
<section id="examples-1" class="level1">
<h1>Examples</h1>
<pre class="jldoctest"><code>julia&gt; diagm([1,2,3])
3×3 Array{Int64,2}:
 1  0  0
 0  2  0
 0  0  3</code></pre>
</section>
</div>
</div>
<p><em>…Neat.</em></p>
<p>Some of you might ask why did I just nonchalantly switch from angular momentum to spin? The short answer is “Because I can”. The long answer is because it’s more appropriate for the problems that follow and it doesn’t really matter. Sometimes (as will be the case of our “real-world” example) quantum objects can have zero regular angular momentum but they still have this internal degree of freedom that we call <a href="https://en.wikipedia.org/wiki/Spin_%28physics%29">spin</a>. It is related to it, but doesn’t come from any real physical rotation. Part of the “related” is that it transforms and behaves in the same way as regular (quantized) angular momentum and can be represented by using the machinery we already have, which is best demonstrated by showing it explicitly:</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sx</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<pre><code>2×2 Array{Float64,2}:
 0.0  0.5
 0.5  0.0</code></pre>
</div>
</div>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sy</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="7">
<pre><code>2×2 Array{Complex{Float64},2}:
  0.0-0.0im  0.0-0.5im
 -0.0+0.5im  0.0-0.0im</code></pre>
</div>
</div>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sz</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="8">
<pre><code>2×2 Array{Float64,2}:
 0.5   0.0
 0.0  -0.5</code></pre>
</div>
</div>
<p>Many of you will recognize that these are, indeed, the <a href="https://en.wikipedia.org/wiki/Pauli_matrices">Pauli spin matrices</a> in units of <span class="math inline">\(\hbar\)</span>.</p>
<p>Knowing this, we can finally get to some tangible physics - electrons in (weak) magnetic fields. For now, we’ll be dealing with just the spin degree of freedom which means that we ignore all the other dynamics. You can pretend that the electron is bound to a hydrogen nucleus in an orbital with zero regular angular momentum (for example the ground-state) and we want to see how the energy of it’s orbitals changes when we apply magnetic field.</p>
<p>First things first: units. Fortunately, there are only two of them in this case. Unfortunately, there are some weird unit conventions out there. The easier one is the unit of magnetic field, Gauss. It’s a <a href="https://en.wikipedia.org/wiki/Centimetre–gram–second_system_of_units">cgs</a> unit commonly used in experimental physics and the conversion to <a href="https://en.wikipedia.org/wiki/International_System_of_Units">SI</a> is 1 T = 10000 G. The stranger one is the unit of energy, MHz, which is a consequence of <a href="https://en.wikipedia.org/wiki/Natural_units">setting the Planck’s constant to 1</a> (see, for example the relation between energy and frequency of a photon <span class="math inline">\(E = \hbar \omega\)</span>). This is a rather common thing to do in physics and it means that, if you see energy in MHz, there’s a silent assumption that we’re actually reporting energy divided by the Planck’s constant. To be able to fully write up the Hamiltonian, we need two more constants. The <a href="https://en.wikipedia.org/wiki/Bohr_magneton">Bohr magneton</a> <span class="math inline">\(\mu_B\)</span> which is a scale factor of the magnetic moment of a electron with given spin or angular momentum and the electron <a href="https://en.wikipedia.org/wiki/G-factor_%28physics%29">g-factor</a> <span class="math inline">\(g_S\)</span> that says how big this magnetic moment is when it comes from the spin of an electron (similar to the gyromagnetic ratio).</p>
<p>It’s smooth sailing from here on. <a href="https://courses.physics.ucsd.edu/2017/Spring/physics4e/magneticmoment.pdf">The potential energy of a (classical) magnetic moment</a> <span class="math inline">\(\vec{m} = (m_x, m_y, m_z)\)</span> in a external magnetic field <span class="math inline">\(\vec{B} = (B_x, B_y, B_z)\)</span> is:</p>
<p><span class="math display">\[ U = \vec{m}\cdot\vec{B}. \]</span></p>
<p>We’re ignoring all the other dynamics of the electron, so writing up the Hamiltonian (<span class="math inline">\(\hat{H} = \hat{T} + \hat{U}\)</span> with <span class="math inline">\(\hat{T} = \hat{0}\)</span>) is as easy as replacing the classical values with their operators:</p>
<p><span class="math display">\[ \hat{H} = -\mu_B g_S \left( \hat{S_x}B_x + \hat{S_y}B_y + \hat{S_z}B_z \right), \]</span></p>
<p>or, in the matrix form:</p>
<p><span class="math display">\[ \hat{H} = -\frac{1}{2} \mu_B g_S \left( \begin{matrix} B_z &amp; B_x - i B_y \\ B_x + i B_y &amp; -B_z \end{matrix} \right), \]</span></p>
<p>Which is coded as</p>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">H_el</span>(b)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    μB <span class="op">=</span> <span class="fl">1.3996245</span>; <span class="co"># Bohr magneton in ħ*MHz/G</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    gS <span class="op">=</span> <span class="op">-</span><span class="fl">2.00231930436</span>; <span class="co"># Electron g-factor</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    prod <span class="op">=</span> @. b[<span class="fl">1</span>] <span class="op">*</span> <span class="fu">sx</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>) <span class="op">+</span> b[<span class="fl">2</span>] <span class="op">*</span> <span class="fu">sy</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>) <span class="op">+</span> b[<span class="fl">3</span>] <span class="op">*</span> <span class="fu">sz</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>)</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    @. <span class="op">-</span>μB <span class="op">*</span> gS <span class="op">*</span> prod</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Through the code, you’ll sometimes see me using me using the <a href="https://docs.julialang.org/en/v1/manual/metaprogramming/index.html#man-macros-1">macro</a> <code>@.</code> or add dots to some of my functions and operators, e.g.&nbsp;<code>.+</code> or <code>abs.(M)</code>. This is so that the compiler can do <a href="https://julialang.org/blog/2017/01/moredots">loop fusion</a> and (hopefully) allow me to gain some performance for cheap. Be careful when using this feature, especially when working with vectors and matrices, where <code>.*</code> is element-wise multiplication and <code>*</code> is matrix-matrix or matrix-vector multiplication.</p>
<p>Let’s try it! First, let’s look at the eigenstates of our Hamiltonian in zero field, e.g.&nbsp;the states in which we can find our electron after measurement:</p>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="fu">eigvecs</span>(<span class="fu">H_el</span>([<span class="fl">0</span>; <span class="fl">0</span>; <span class="fl">0</span>]))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="10">
<pre><code>2×2 Array{Complex{Float64},2}:
 1.0+0.0im  0.0+0.0im
 0.0+0.0im  1.0+0.0im</code></pre>
</div>
</div>
<p>We see that the two eigenstates (columns of the resulting matrix) are <span class="math inline">\(\left| \frac{1}{2}, \frac{1}{2}\right&gt; = \left| \uparrow \right&gt; = (1,0)\)</span> and <span class="math inline">\(\left| \frac{1}{2}, -\frac{1}{2}\right&gt; = \left| \downarrow \right&gt; = (0,1)\)</span> - the spin-up and spin-down state. The energy eigenvalues are</p>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">eigvals</span>(<span class="fu">H_el</span>([<span class="fl">0</span>; <span class="fl">0</span>; <span class="fl">0</span>]))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="11">
<pre><code>2-element Array{Float64,1}:
 0.0
 0.0</code></pre>
</div>
</div>
<p>…unsurprising. There’s no field, so both states have same energy of 0 relative to the ground-state energy - the ground state is <a href="https://en.wikipedia.org/wiki/Degenerate_energy_levels">degenerate</a>, which is something that will be a considerable pain in the ass later on with fancier methods. This is also the reason why atomic orbitals can take at least two electrons (or an even number, if there’s more of them and they have angular momentum) - even if they are <a href="https://en.wikipedia.org/wiki/Fermion">fermions</a> and being in the same state is forbidden by the <a href="https://en.wikipedia.org/wiki/Pauli_exclusion_principle">Pauli exclusion principle</a>, they can sit in the same orbital with different spin projections, which makes them two distinct states.</p>
<p>Let’s plot the two state energies as a function of applied magnetic field (in the z-direction):</p>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>b_range <span class="op">=</span> <span class="fl">0</span><span class="op">:</span><span class="fl">5</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>energies <span class="op">=</span> <span class="fu">vcat</span>((<span class="fu">eigvals</span>(<span class="fu">H_el</span>([<span class="fl">0</span>; <span class="fl">0</span>; b]))<span class="ch">' for b in b_range)...)</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(b_range, energies, xlabel<span class="op">=</span><span class="st">"B [G]"</span>, ylabel<span class="op">=</span><span class="st">"E [MHz]"</span>, leg<span class="op">=</span><span class="cn">false</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="12">
<p><img src="index_files/figure-html/cell-13-output-1.svg" class="img-fluid"></p>
</div>
</div>
<p><em>The ugly line <code>vcat((eigvals(H_el([0 0 b]))' for b in b_range)...)</code> calculates the eigenvalues for multiple values of field <code>b</code> (in range from 0 to 5 Gauss) and stacks them into a matrix. This is purely so that it can be conveniently plotted using the <code>plot</code> function that plots columns as individual lines.</em></p>
<p>The energy levels start to separate as the applied field increases in magnitude, analogously to how it works with classical magnetic moments. The spin aligned with the field sits in a ever-deeper a potential well (classically, you would need to do more work to tilt it) and the spin anti-parallel becomes higher in energy (more work is needed to align it in that direction). The energy difference between the two states is proportional to the field and is known as the <a href="https://en.wikipedia.org/wiki/Zeeman_effect">Zeeman effect</a>, which will be important for the star of today’s show. But before that, we need to get two spins to interact.</p>
</section>
<section id="search-for-more-spaces-or-how-many-bits-does-it-take-to-store-the-concept-of-multiple-sine-functions" class="level2">
<h2 class="anchored" data-anchor-id="search-for-more-spaces-or-how-many-bits-does-it-take-to-store-the-concept-of-multiple-sine-functions">Search for more space(s) or: How many bits does it take to store the concept of multiple sine functions?</h2>
<p>Unless you’re working on quantum computing, a single two-level state as shown above is quite boring. To give a little bit more structure to our system, we’ll look at something with more degrees of freedom: a single atom of Rubidium-87. Before we get to the specifics, we need to talk a bit about systems with multiple (coupled) degrees of freedom.</p>
<section id="whats-a-otimes" class="level3">
<h3 class="anchored" data-anchor-id="whats-a-otimes">What’s a <span class="math inline">\(\otimes\)</span>?</h3>
<p>In the case we have shown before, there was only one degree of freedom of the system - the spin. Correspondingly, the Hamiltonian acted only on this degree of freedom and encompassed all the interesting dynamics. But this will not always be the case. You can easily imagine a situation, where there’s more to the it than just the dynamics of a single state variable: For example, you could have multiple spins sitting on a chain or lattice and interact together. How do we conveniently write down a Hamiltonian for a system like this? Well, the system is a sum of its parts, so it’s not irrational to try to do it like this:</p>
<p><span class="math display">\[\hat{H} = \left( \sum_k \hat{H}^{(k)} \right) + \hat{H}_{int}.\]</span></p>
<p>The individual degrees of freedom are described by their individual (sub-)Hamiltonians <span class="math inline">\(\hat{H}^{(k)}\)</span> and, if we continue with the example of the chain of spins in magnetic field, <span class="math inline">\(\hat{H}^{(k)}\)</span> would be the spin Hamiltonian acting exclusively on the k-th spin. Operators corresponding to interaction between the spins (e.g.&nbsp;<a href="https://en.wikipedia.org/wiki/Exchange_interaction">exchange interactions</a>) are all hidden in <span class="math inline">\(\hat{H}_{int}\)</span> which will act on the system as a whole. Formally speaking, the ability to split the Hamiltonian so neatly hinges on the total Hilbert space having a <a href="https://en.wikipedia.org/wiki/Tensor_product">tensor-product structure</a> - in the context of our discussion in the previous part, the state of the whole system can be described by enumerating states of all it’s subsystems. This is not always the case and we’ll be dealing with situations where it all comes crashing to the ground in the future. But it’s going to work out fine this time, so let’s focus on how to implement it.</p>
<p>If the Hilbert space <span class="math inline">\(H\)</span> can be factorized into subspaces corresponding to the N individual degrees of freedom as</p>
<p><span class="math display">\[ H = H^{(1)} \otimes H^{(2)} \otimes \ldots \otimes H^{(N)}, \]</span></p>
<p>where <span class="math inline">\(\otimes\)</span> is the tensor product, then a single sub-Hamiltonian can be constructed as</p>
<p><span class="math display">\[ \hat{H}^{(k)} = \mathbf{1}^{(1)} \otimes \mathbf{1}^{(2)} \otimes \ldots \otimes \mathbf{1}^{(k-1)} \otimes \hat{h}^{(k)} \otimes \mathbf{1}^{(k+1)} \otimes \ldots \otimes \mathbf{1}^{(N)}, \]</span></p>
<p>where <span class="math inline">\(\hat{h}^{(k)}\)</span> is the Hamiltonian of a single degree of freedom, e.g.&nbsp;<span class="math inline">\(\hat{h} = -\mu_B g_S \hat{S_z}B_z\)</span> for spins in longitudinal field. This extends to the basis of the whole system, which is constructed by using all the tensor products of the subspace basis function sets <span class="math inline">\(\{ \left| \phi_{i_k} \right&gt; ^{(k)} \} _{i_k = 1} ^{n_k}\)</span>, i.e.:</p>
<p><span class="math display">\[ \left| \phi_{i_1}, \phi_{i_2}, \ldots, \phi_{i_N} \right&gt; = \left| \phi_{i_1} \right&gt;^{(1)} \otimes \left| \phi_{i_2} \right&gt;^{(2)} \otimes ... \otimes \left| \phi_{i_N} \right&gt;^{(N)}.\]</span></p>
<p>Product spaces can become <em>really</em> large quickly, as the number of elements in the basis goes as <span class="math inline">\(\prod_{k=1}^N n_k\)</span>, with <span class="math inline">\(n_k\)</span> being the number of elements of k-th subspace basis. This is one of the main reasons why I initially said that this direct approach will eventually fail - even for just a simple system like a spin chain (two basis vectors per subsystem), the basis for N spins has <span class="math inline">\(\mathrm{2^N}\)</span> elements, which is a scaling that gives computer scientists the heebie-jeebies.</p>
<p>Following the same discussion as in Part 0, we can express the computer representation of a product state</p>
<p><span class="math display">\[ \left| \psi \right&gt; = \left| \psi_1 \right&gt;^{(1)} \otimes \left| \psi_2 \right&gt;^{(2)} \otimes \ldots \otimes \left| \psi_N \right&gt;^{(N)} = \sum_{i_1 = 1}^{n_1} \sum_{i_2 = 1}^{n_2}\ldots\sum_{i_n = 1}^{n_N} \psi_{i_1,i_2,\ldots,i_N} \left| \phi_{i_1},\phi_{i_2},\ldots,\phi_{i_N} \right&gt;, \]</span></p>
<p>where <span class="math inline">\(\psi_{i_1,i_2,...,i_N}\)</span> is the vector stored in memory. To calculate this this product state in Julia, we use the <a href="https://en.wikipedia.org/wiki/Kronecker_product">Kronecker product</a> by simply doing, e.g.&nbsp;<code>ψ = kron(ψ1, ψ2, ψ3)</code> to get a product of states <code>ψ1</code>, <code>ψ2</code> and <code>ψ3</code> (you can use as many states as you need, the <code>kron</code> function is <a href="https://en.wikipedia.org/wiki/Variadic_function">variadic</a>). The operators acting on the full Hilbert space will follow the same logic:</p>
<p><span class="math display">\[ \hat{A} = \hat{a}_1^{(1)} \otimes \hat{a}_2^{(2)} \otimes \ldots \otimes \hat{a}_N^{(N)} = \sum_{i_1=1}^{n_1}\sum_{j_1=1}^{n_1} \sum_{i_2=1}^{n_2}\sum_{j_2=1}^{n_2} \ldots \sum_{i_N=1}^{n_N}\sum_{j_N=1}^{n_N} \left[ a_{i_1j_1}^{(1)} a_{i_2j_2}^{(2)} \ldots a_{i_Nj_N}^{(N)} \right] \left| \phi_{i_1},\phi_{i_2},\ldots,\phi_{i_N} \right&gt; \left&lt; \phi_{i_1},\phi_{i_2},\ldots,\phi_{i_N} \right| = \\ \sum_{i_1=1}^{n_1}\sum_{j_1=1}^{n_1} \sum_{i_2=1}^{n_2}\sum_{j_2=1}^{n_2} \ldots \sum_{i_N=1}^{n_N}\sum_{j_N=1}^{n_N} a_{i_1j_1 i_2j_2 \ldots i_Nj_N} \left| \phi_{i_1},\phi_{i_2},\ldots,\phi_{i_N} \right&gt; \left&lt; \phi_{i_1},\phi_{i_2},\ldots,\phi_{i_N} \right|, \]</span></p>
<p>where the monstrosity <span class="math inline">\(a_{i_1j_1 i_2j_2 \ldots i_Nj_N}\)</span> is the operator matrix used in calculations. Writing so many summation symbols and indices in a single expression has already cost me probably half of my readers, so before I lose the rest of you: To make a full operator matrix <code>A</code> out of subspace operators <code>A1</code>, <code>A2</code> and <code>A3</code>, you use the same function as before, i.e.&nbsp;<code>A = kron(A1, A2, A3)</code>. It’s just that easy.</p>
<p>This should give us all that’s necessary to do the first real-world physics.</p>
</section>
<section id="the-not-so-curious-case-of-mathrm87rb" class="level3">
<h3 class="anchored" data-anchor-id="the-not-so-curious-case-of-mathrm87rb">The not-so-curious case of <span class="math inline">\(\mathrm{^{87}Rb}\)</span></h3>
<p>We started with spin Hamiltonians because they are easy to work with and demonstrate basic concepts on, but that doesn’t mean that there’s no use for these systems in the wild. There’s a lot of applications in <a href="https://en.wikipedia.org/wiki/Atomic,_molecular,_and_optical_physics">AMO physics</a> that use transitions between atomic angular momentum or spin states, such as <a href="https://en.m.wikipedia.org/wiki/Atomic_clock">atomic clocks</a> and these transitions in Caesium are even used as a standard which <a href="https://en.wikipedia.org/wiki/Caesium_standard">defines the length of a second</a>. While less precise than Caesium, the <a href="https://en.wikipedia.org/wiki/Rubidium_standard">Rubidium-87 standard</a> is much more common and used in applications that require precise timing, such as GPS satellites or cell towers, and we’ll look at its spin structure.</p>
<p>Rubidium is an alkali metal with 36 core electrons that completely fill the principal energy levels and don’t contribute to the atom’s spin or angular momentum (a fully filled electron shell is isotropic) and a single valence electron that has zero angular momentum and spin of 1/2 (that is, in the electronic ground-state). The slightly radioactive (with half-life of 49 billion years, so only <em>very</em> slightly) isotope <span class="math inline">\(\mathrm{^{87}Rb}\)</span> has a nuclear spin of 3/2. These fully define the spin system that we’ll look at and, from the discussion in the preceding paragraphs, the basis of our Hamiltonian will be a tensor product basis of spin-3/2, spin-1/2 and spin-0 spaces. The operators act only on their respective subspaces, so their action on the total space is defined really easily: <span class="math inline">\(\hat{\mathbf{I}} \mapsto \hat{\mathbf{I}} \otimes \hat{\mathbf{1}} \otimes \hat{\mathbf{1}}\)</span>, <span class="math inline">\(\hat{\mathbf{S}} \mapsto \hat{\mathbf{1}} \otimes \hat{\mathbf{S}} \otimes \hat{\mathbf{1}}\)</span> and <span class="math inline">\(\hat{\mathbf{L}} \mapsto \hat{\mathbf{1}} \otimes \hat{\mathbf{1}} \otimes \hat{\mathbf{L}}\)</span> for the nuclear spin, electron spin and electron orbital angular momentum, respectively (total electron angular momentum is <span class="math inline">\(\hat{\mathbf{J}} = \hat{\mathbf{S}} + \hat{\mathbf{L}}\)</span>). We’ll limit ourselves to only spin dipole-dipole interactions (see <a href="https://steck.us/alkalidata/rubidium87numbers.pdf">here</a>) which means that the Hamiltonian in longitudinal field looks like this:</p>
<p><span class="math display">\[ \hat{H}_0 = h A_{hfs}\hat{\mathbf{I}} \cdot \hat{\mathbf{J}} - \mu_B B_Z \left( g_I \hat{I}_z + g_S \hat{S}_z + g_L \hat{L}_z \right) ,\]</span></p>
<p>where <span class="math inline">\(A_{hfs}\)</span> is the spin-spin coupling constant for <span class="math inline">\(\mathrm{^{87}Rb}\)</span> ground-state, <span class="math inline">\(g_I\)</span>, <span class="math inline">\(g_S\)</span> and <span class="math inline">\(g_L\)</span> the g-factors of the various forms of angular momentum in the system and <span class="math inline">\(h\)</span> the Planck’s constant (equal to 1 in our units). Putting that into Julia code is as easy as writing out the individual operator components and summing/multiplying them (you’ll see why I give it the index 0 momentarily):</p>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">H0</span>(bz)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    ahfs <span class="op">=</span> <span class="fl">3417.341305</span>; <span class="co"># spin-spin coupling const for ⁸⁷Rb</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    gS <span class="op">=</span> <span class="op">-</span><span class="fl">2.00231930436</span>; <span class="co"># Electron g-factor</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    gI <span class="op">=</span> <span class="fl">0.0009951414</span>; <span class="co"># Nuclear g-factor</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    gL <span class="op">=</span> <span class="op">-</span><span class="fl">0.99999369</span>; <span class="co"># Electron orbital g-factor</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>    μB <span class="op">=</span> <span class="fl">1.3996245</span>; <span class="co"># Bohr magneton in ħ*MHz/G</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Nuclear spin</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    Ix <span class="op">=</span> <span class="fu">kron</span>(<span class="fu">sx</span>(<span class="fl">3</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">0</span>));</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    Iy <span class="op">=</span> <span class="fu">kron</span>(<span class="fu">sy</span>(<span class="fl">3</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">0</span>));</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    Iz <span class="op">=</span> <span class="fu">kron</span>(<span class="fu">sz</span>(<span class="fl">3</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">0</span>));</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Electron spin</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>    Sx <span class="op">=</span> <span class="fu">kron</span>(<span class="fu">sid</span>(<span class="fl">3</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sx</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">0</span>));</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>    Sy <span class="op">=</span> <span class="fu">kron</span>(<span class="fu">sid</span>(<span class="fl">3</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sy</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">0</span>));</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>    Sz <span class="op">=</span> <span class="fu">kron</span>(<span class="fu">sid</span>(<span class="fl">3</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sz</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">0</span>));</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Electron angular momentum</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>    Lx <span class="op">=</span> <span class="fu">kron</span>(<span class="fu">sid</span>(<span class="fl">3</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sx</span>(<span class="fl">0</span>));</span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>    Ly <span class="op">=</span> <span class="fu">kron</span>(<span class="fu">sid</span>(<span class="fl">3</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sy</span>(<span class="fl">0</span>));</span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>    Lz <span class="op">=</span> <span class="fu">kron</span>(<span class="fu">sid</span>(<span class="fl">3</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sz</span>(<span class="fl">0</span>));</span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Total electron angular momentum</span></span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>    Jx <span class="op">=</span> Sx <span class="op">.+</span> Lx;</span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>    Jy <span class="op">=</span> Sy <span class="op">.+</span> Ly;</span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>    Jz <span class="op">=</span> Sz <span class="op">.+</span> Lz;</span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a>    so <span class="op">=</span> ahfs <span class="op">.*</span> (Ix <span class="op">*</span> Jx <span class="op">.+</span> Iy <span class="op">*</span> Jy <span class="op">.+</span> Iz <span class="op">*</span> Jz);</span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a>    sb <span class="op">=</span> @. μB <span class="op">*</span> bz <span class="op">*</span> (gI <span class="op">*</span> Iz <span class="op">+</span> gS <span class="op">*</span> Sz <span class="op">+</span> gL <span class="op">*</span> Lz);</span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>    so <span class="op">.-</span> sb</span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here is where the spin identity operators <code>sid</code> come into play. Their only purpose is to generate an identity matrix that has the same size as a non-trivial operator acting on the subspace. It’s also worth pointing out that the electron angular momentum <span class="math inline">\(\hat{\mathbf{L}}\)</span> has only one state, which means that it doesn’t actually contribute to anything and it’s here just for completeness sake. We can take it for a ride in the same way as with just the bare spin before:</p>
<div class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>b_range <span class="op">=</span> <span class="fl">0</span><span class="op">:</span><span class="fl">8000</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>energies <span class="op">=</span> <span class="fu">vcat</span>((<span class="fu">eigvals</span>(<span class="fu">H0</span>(b))<span class="ch">' for b in b_range)...)</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(b_range, energies, xlabel<span class="op">=</span><span class="st">"B [G]"</span>, ylabel<span class="op">=</span><span class="st">"E [MHz]"</span>, leg<span class="op">=</span><span class="cn">false</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="14">
<p><img src="index_files/figure-html/cell-15-output-1.svg" class="img-fluid"></p>
</div>
</div>
<p>Now this finally gives us something to talk about. First: yes, it does actually look exactly as it’s <a href="https://en.wikipedia.org/wiki/Zeeman_effect#/media/File:Breit-rabi-Zeeman.png">supposed to</a>. Second: What the hell is happening with the energy levels? Not knowing the details, you would expect to zero-field state to be just a eight-fold degenerate ground state of all the individual spin states living in peace and harmony. But it’s not. Instead you see that, even at zero field, there are two separate energy levels. This is because the angular momenta in the atom are coupled (through the <span class="math inline">\(\hat{\mathbf{I}}\cdot\hat{\mathbf{J}}\)</span> term). Since nuclear and electronic spins (or angular momenta, whatever) are of length 3/2 and 1/2, the full system can only be in a state with total atom spin <span class="math inline">\(\hat{\mathbf{F}} = \hat{\mathbf{I}} + \hat{\mathbf{J}}\)</span> of either F = 1 (a three-fold degenerate state), or F = 2 (with five-fold degeneracy). This forms the famous <a href="https://en.wikipedia.org/wiki/Hyperfine_structure">hyperfine structure</a>. To confirm the assignment, we can take the energy eigenstates <span class="math inline">\(\{ \left| \varepsilon_i \right&gt; \}_{i=1}^{8}\)</span> of the Hamiltonian and check if <span class="math inline">\(\left&lt; \varepsilon_i \right| \hat{F}_z \left| \varepsilon_j \right&gt;\)</span> and <span class="math inline">\(\left&lt; \varepsilon_i \right| \hat{F}^2 \left| \varepsilon_j \right&gt;\)</span> are diagonal:</p>
<div class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>evecs <span class="op">=</span> <span class="fu">eigvecs</span>(<span class="fu">H0</span>(<span class="fl">0.0</span>)) <span class="co"># Energy eigenvectors</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">Fz</span>()</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Nuclear spin</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    Iz <span class="op">=</span> <span class="fu">kron</span>(<span class="fu">sz</span>(<span class="fl">3</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">0</span>));</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Electron spin</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>    Sz <span class="op">=</span> <span class="fu">kron</span>(<span class="fu">sid</span>(<span class="fl">3</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sz</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">0</span>));</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Electron angular momentum</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>    Lz <span class="op">=</span> <span class="fu">kron</span>(<span class="fu">sid</span>(<span class="fl">3</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sz</span>(<span class="fl">0</span>));</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Total electron angular momentum</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>    Jz <span class="op">=</span> Sz <span class="op">.+</span> Lz;</span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Total atomic angular momentum</span></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>    Iz <span class="op">.+</span> Jz</span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">F2</span>()</span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Nuclear spin</span></span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a>    Ix <span class="op">=</span> <span class="fu">kron</span>(<span class="fu">sx</span>(<span class="fl">3</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">0</span>));</span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a>    Iy <span class="op">=</span> <span class="fu">kron</span>(<span class="fu">sy</span>(<span class="fl">3</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">0</span>));</span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a>    Iz <span class="op">=</span> <span class="fu">kron</span>(<span class="fu">sz</span>(<span class="fl">3</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">0</span>));</span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Electron spin</span></span>
<span id="cb27-24"><a href="#cb27-24" aria-hidden="true" tabindex="-1"></a>    Sx <span class="op">=</span> <span class="fu">kron</span>(<span class="fu">sid</span>(<span class="fl">3</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sx</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">0</span>));</span>
<span id="cb27-25"><a href="#cb27-25" aria-hidden="true" tabindex="-1"></a>    Sy <span class="op">=</span> <span class="fu">kron</span>(<span class="fu">sid</span>(<span class="fl">3</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sy</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">0</span>));</span>
<span id="cb27-26"><a href="#cb27-26" aria-hidden="true" tabindex="-1"></a>    Sz <span class="op">=</span> <span class="fu">kron</span>(<span class="fu">sid</span>(<span class="fl">3</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sz</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">0</span>));</span>
<span id="cb27-27"><a href="#cb27-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Electron angular momentum</span></span>
<span id="cb27-28"><a href="#cb27-28" aria-hidden="true" tabindex="-1"></a>    Lx <span class="op">=</span> <span class="fu">kron</span>(<span class="fu">sid</span>(<span class="fl">3</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sx</span>(<span class="fl">0</span>));</span>
<span id="cb27-29"><a href="#cb27-29" aria-hidden="true" tabindex="-1"></a>    Ly <span class="op">=</span> <span class="fu">kron</span>(<span class="fu">sid</span>(<span class="fl">3</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sy</span>(<span class="fl">0</span>));</span>
<span id="cb27-30"><a href="#cb27-30" aria-hidden="true" tabindex="-1"></a>    Lz <span class="op">=</span> <span class="fu">kron</span>(<span class="fu">sid</span>(<span class="fl">3</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sz</span>(<span class="fl">0</span>));</span>
<span id="cb27-31"><a href="#cb27-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb27-32"><a href="#cb27-32" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Total electron angular momentum</span></span>
<span id="cb27-33"><a href="#cb27-33" aria-hidden="true" tabindex="-1"></a>    Jx <span class="op">=</span> Sx <span class="op">.+</span> Lx;</span>
<span id="cb27-34"><a href="#cb27-34" aria-hidden="true" tabindex="-1"></a>    Jy <span class="op">=</span> Sy <span class="op">.+</span> Ly;</span>
<span id="cb27-35"><a href="#cb27-35" aria-hidden="true" tabindex="-1"></a>    Jz <span class="op">=</span> Sz <span class="op">.+</span> Lz;</span>
<span id="cb27-36"><a href="#cb27-36" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb27-37"><a href="#cb27-37" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Total atomic angular momentum</span></span>
<span id="cb27-38"><a href="#cb27-38" aria-hidden="true" tabindex="-1"></a>    Fx <span class="op">=</span> Ix <span class="op">.+</span> Jx</span>
<span id="cb27-39"><a href="#cb27-39" aria-hidden="true" tabindex="-1"></a>    Fy <span class="op">=</span> Iy <span class="op">.+</span> Jy</span>
<span id="cb27-40"><a href="#cb27-40" aria-hidden="true" tabindex="-1"></a>    Fz <span class="op">=</span> Iz <span class="op">.+</span> Jz</span>
<span id="cb27-41"><a href="#cb27-41" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb27-42"><a href="#cb27-42" aria-hidden="true" tabindex="-1"></a>    Fx<span class="op">*</span>Fx <span class="op">.+</span> Fy<span class="op">*</span>Fy <span class="op">.+</span> Fz<span class="op">*</span>Fz</span>
<span id="cb27-43"><a href="#cb27-43" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>I’ll cheat a little bit and take only the real part of the eigenvectors (the imaginary part in this case is zero) and get rid floating-point arithmetic errors so that the matrices look pretty. The <span class="math inline">\(\hat{F}_z\)</span> eigenvalues are out of order because the ordering of the degenerate energy eigenstates is arbitrary.</p>
<div class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="fu">Int</span>.(<span class="fu">round</span>.(<span class="fu">real</span>.(<span class="fu">transpose</span>(evecs) <span class="op">*</span> <span class="fu">F2</span>() <span class="op">*</span> evecs)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="16">
<pre><code>8×8 Array{Int64,2}:
 2  0  0  0  0  0  0  0
 0  2  0  0  0  0  0  0
 0  0  2  0  0  0  0  0
 0  0  0  6  0  0  0  0
 0  0  0  0  6  0  0  0
 0  0  0  0  0  6  0  0
 0  0  0  0  0  0  6  0
 0  0  0  0  0  0  0  6</code></pre>
</div>
</div>
<div class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="fu">Int</span>.(<span class="fu">round</span>.(<span class="fu">real</span>.(<span class="fu">transpose</span>(evecs) <span class="op">*</span> <span class="fu">Fz</span>() <span class="op">*</span> evecs)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="17">
<pre><code>8×8 Array{Int64,2}:
 1  0   0  0  0  0   0   0
 0  0   0  0  0  0   0   0
 0  0  -1  0  0  0   0   0
 0  0   0  1  0  0   0   0
 0  0   0  0  0  0   0   0
 0  0   0  0  0  2   0   0
 0  0   0  0  0  0  -1   0
 0  0   0  0  0  0   0  -2</code></pre>
</div>
</div>
<p>As you can see, the Hamiltonian does, indeed, commute with the atomic angular momentum operators and we can label the states by the atomic angular momentum quantum numbers as <span class="math inline">\(\left| f, m_f \right&gt;\)</span>. This approximately holds also for small fields, where the three <span class="math inline">\(\left| 1, m_1 \right&gt;\)</span> and five <span class="math inline">\(\left| 2, m_2 \right&gt;\)</span> states Zeeman split, with the field dependence of the energy shifts being approximately linear with two different effective g-factors. At high fields, we cannot do this anymore and we need identify the eigenstates of the Hamiltonian with states <span class="math inline">\(\left|m_I, m_J \right&gt; = \left|\frac{3}{2}, m_I \right&gt; \otimes \left| \frac{1}{2}, m_J \right&gt;\)</span> (the author is too lazy to do it, so the confirmation of this is, again, left as a exercise for the reader).</p>
<p>This is as far as we’ll go with the discussion on static ground states. If you feel like you had enough and need a break, now is probably the time to do it. Otherwise, let’s move on to the other promise of this part’s title, which implies also some dynamics.</p>
</section>
<section id="programming-the-prime-mover" class="level3">
<h3 class="anchored" data-anchor-id="programming-the-prime-mover">Programming the prime mover</h3>
<p>Calculating properties of the static ground state was easy because it amounted to just finding the eigenstates of a static Hamiltonian. But dynamics are a bit more tricky. What we have to solve is the time-dependent Schrödinger equation:</p>
<p><span class="math display">\[ i\hbar \frac{d}{dt} \left|\psi(t) \right&gt; = \hat{H}(t) \left|\psi(t) \right&gt;. \]</span></p>
<p>If I were a theorist, I could say that the solution is easy and just write it down as</p>
<p><span class="math display">\[ \left|\psi(t) \right&gt; = \hat{U}(t_0, t) \left|\psi(t_0) \right&gt;, \]</span></p>
<p>Where <span class="math inline">\(\hat{U}(t_0, t)\)</span> is called the <a href="https://en.wikipedia.org/wiki/Propagator">propagator</a>, and just by skimming the Wikipedia article, you can probably tell that this “solution” is not too useful for us. The propagator, which is in this case the time evolution operator, has to have <a href="https://www.oulu.fi/tf/kvmIII/english/2004/03_timeoper.pdf">certain properties</a> - it needs to conserve probability, meaning that the system always has to be in <em>some</em> state, and it has to be composable, i.e.&nbsp;<span class="math inline">\(\hat{U}(t_0, t_2) = \hat{U}(t_0, t_1)\hat{U}(t_1, t_2)\)</span>. By accepting these demands and following the ritualistic practices of mathematics, you can arrive at a more specific form:</p>
<p><span class="math display">\[ \hat{U}(t_0, t) = \exp{\left[ -\frac{i}{\hbar} \int_{t_0}^t d\tau \hat{H}(\tau) \right]}. \]</span></p>
<p>The question immediately becomes, how does one do an exponent of a operator? Ehh, you don’t really. What you can do is a <a href="https://en.wikipedia.org/wiki/Series_expansion">series expansion</a>, which in this case gives an infinite series of operators called the <a href="https://en.wikipedia.org/wiki/Dyson_series">Dyson series</a>:</p>
<p><span class="math display">\[ \hat{U}(t_0, t) = \hat{\mathbf{1}} - \frac{i}{\hbar} \int_{t_0}^{t}d\tau \hat{H}(\tau_1) - \frac{1}{\hbar^2} \int_{t_0}^{t}d\tau\int_{t_0}^{\tau}d\tau_1\hat{H}(\tau)\hat{H}(\tau_1) + \frac{i}{\hbar^3} \int_{t_0}^{t}d\tau\int_{t_0}^{\tau}d\tau_1\int_{t_0}^{\tau_1}d\tau_2\hat{H}(\tau)\hat{H}(\tau_1)\hat{H}(\tau_2) + \ldots. \]</span></p>
<p>A series not dissimilar to this one is what’s encoded in Feynman diagrams, but that’s something the future us will work with. Alternatively, one can use the <a href="https://en.wikipedia.org/wiki/Magnus_expansion">Magnus expansion</a>:</p>
<p><span class="math display">\[ \hat{U}(t_0, t_1) = \exp{\left[ \sum_k \hat{\Omega}_k(t_0,t) \right]}, \]</span></p>
<p>where</p>
<p><span class="math display">\[ \hat{\Omega}_1(t_0,t) = -\frac{i}{\hbar} \int_{t_0}^t d\tau \hat{H}(\tau), \\
\hat{\Omega}_2(t_0,t) = -\frac{1}{2\hbar^2} \int_{t_0}^t d\tau \int_{t_0}^{\tau} d\tau_1 \left[ \hat{H}(\tau), \hat{H}(\tau_1) \right], \\
\hat{\Omega}_3(t_0,t) = -\frac{1}{6\hbar^3} \int_{t_0}^t d\tau \int_{t_0}^{\tau} d\tau_1 \int_{t_0}^{\tau_1} d\tau_2 \left[ \hat{H}(\tau), [\hat{H}(\tau_1), \hat{H}(\tau_2)] \right] + \left[ \hat{H}(\tau_2), [\hat{H}(\tau_1), \hat{H}(\tau)] \right], \\
\ldots \]</span></p>
<p>This expansion shows, that the time propagator simplifies by a considerable amount, if the Hamiltonian commutes with itself at different times, <span class="math inline">\(\left[\hat{H}(t), \hat{H}(t') \right] = 0\)</span>, which leaves you with just the <span class="math inline">\(\hat{\Omega}_1(t_0, t)\)</span> term and that becomes even easier if the Hamiltonian itself is time-independent. But don’t get your hopes too high up - most interesting problems aren’t like this.</p>
<p>Until now, I have been just adding integrals and operators to somehow express the state in a future time, but that doesn’t bring us much closer to actually solving the Schrödinger equation in a concrete manner. Let’s do that numerically, first, with a time-independent basis. This means that the basis <span class="math inline">\(\{ \left| \phi_i \right&gt; \}\)</span> is fixed and it’s the operator and wavefunction expansion coefficients that change in time. By doing that, the Schrödinger equation takes the form</p>
<p><span class="math display">\[ i\hbar \sum_i \frac{d}{dt} \psi_i(t) \left| \phi_i \right&gt; = \sum_{jk} H_{jk}(t)\psi_k(t) \left| \phi_j \right&gt;, \]</span></p>
<p>which, after multiplying from the left by <span class="math inline">\(\left&lt; \phi_m \right|\)</span> yields</p>
<p><span class="math display">\[ i\hbar\frac{d}{dt} \psi_m(t) = \sum_k H_{mk}(t)\psi_k(t), \]</span></p>
<p>where <span class="math inline">\(\psi_{m,k}\)</span> and <span class="math inline">\(H_{mk}\)</span> are just regular complex numbers (the basis is orthogonal, so <a href="https://en.wikipedia.org/wiki/Kronecker_delta"><span class="math inline">\(\left&lt; \phi_i | \phi_j \right&gt; = \delta_{ij}\)</span></a>). This coupled system of differential equations, which we can rewrite as a vector equation <span class="math inline">\(i\hbar \frac{d}{dt}\vec{\psi}(t) = \mathbf{H}(t)\cdot \vec{\psi}\)</span>, can be solved on the computer by any method or library you desire.</p>
<p>There is, however, a more convenient way to represent the problem in our case: the <a href="https://en.wikipedia.org/wiki/Interaction_picture">interaction picture</a>. In this case, we split the Hamiltonian into a time-independent part and a time-dependent part containing the interactions that cause system dynamics: <span class="math inline">\(\hat{H}(t) = \hat{H}_0 + \hat{H}_1(t)\)</span> (now you understand my choice of indexing the hyperfine Hamiltonian with 0). If we can diagonalize the time-independent Hamiltonian, i.e.&nbsp;find the eigenfunction basis</p>
<p><span class="math display">\[ \hat{H}_0 \left| \phi_i \right&gt; = E_i \left| \phi_i \right&gt;, \]</span></p>
<p>We can use it come up with a time-dependent basis in the form</p>
<p><span class="math display">\[ \left| \phi_i(t) \right&gt; = e^{-\frac{i E_i}{\hbar}t} \left| \phi_i \right&gt;. \]</span></p>
<p><em>(be careful not to confuse the complex <span class="math inline">\(i\)</span> with the subscript index i)</em></p>
<p>In this basis, the time-dependent Schrödinger equation is</p>
<p><span class="math display">\[ i\hbar \sum_i \frac{d}{dt}\psi_i e^{-\frac{i E_i}{\hbar}t} \left| \phi_i \right&gt; = \sum_j \psi_j e^{-\frac{i E_j}{\hbar}t} \hat{H}_1(t) \left| \phi_j \right&gt; \]</span></p>
<p>which, again, by doing left multiplication by <span class="math inline">\(\left&lt; \phi_k \right|\)</span> becomes</p>
<p><span class="math display">\[ i\hbar\frac{d}{dt}\psi_k(t) = \sum_j \psi_j(t)e^{-\frac{i (E_j - E_k)}{\hbar}t} \left&lt; \phi_k \right| \hat{H}_1(t) \left| \phi_j \right&gt;. \]</span></p>
<p>This is the same as the equation in time-independent basis, but with the dynamics encoded in the matrix <span class="math inline">\(H_{mk} \equiv H_{ij} = e^{-\frac{i (E_i - E_j)}{\hbar}t} \left&lt; \phi_i \right| \hat{H}_1 \left| \phi_j \right&gt;\)</span>.</p>
</section>
<section id="seeing-the-light" class="level3">
<h3 class="anchored" data-anchor-id="seeing-the-light">Seeing the light</h3>
<p>Armed with the knowledge of how to solve time-dependent problems, we can check what happens if the Rubidium atom is coupled to a oscillating magnetic field. The oscillating magnetic field can be also the magnetic component of a traveling electromagnetic wave, so we’re effectively looking at the behavior of the atom under light illumination. As per previous discussion, we’ll write down the Hamiltonian as a sum of the time-independent part (which is the hyperfine Hamiltonian that we used previously) and the oscillating perturbation part:</p>
<p><span class="math display">\[ \hat{H}(t) = \hat{H}_0 + \cos(\omega t)\hat{H}_1 = h A_{hfs}\hat{\mathbf{I}} \cdot \hat{\mathbf{J}} - \mu_B B_Z \left( g_I \hat{I}_z + g_S \hat{S}_z + g_L \hat{L}_z \right) - cos{( \omega t)} \times \mu_B \vec{B}_{ac} \cdot \left( g_I \hat{\mathbf{I}} + g_S \hat{\mathbf{S}} + g_L \hat{\mathbf{L}} \right), \]</span></p>
<p>where <span class="math inline">\(\vec{B}_{ac}\)</span> is the magnetic field of the EM wave with angular frequency <span class="math inline">\(\omega\)</span>. Unfortunately, <span class="math inline">\(\left[ \hat{H}(t), \hat{H}(t') \right] \neq 0\)</span>, so there’s very little hope for us to find an analytic solution to this problem (AFAIK, it doesn’t exist) and the numerical solution that we’ll attempt here is about as good as it gets. We already have the eigenstates of the Hamiltonian <span class="math inline">\(\hat{H}_0\)</span>, so we can use them to construct the set of equations that we need to solve:</p>
<p><span class="math display">\[ i\hbar\frac{d}{dt}\psi_i(t)=\sum_{j=1}^8 \psi_j(t) e^{\frac{-i(E_j - E_i)}{\hbar}t} cos{(\omega t)}\left&lt; \phi_i \right| \hat{H}_1 \left| \phi_j \right&gt;
= \frac{1}{2} \sum_{j=1}^8 \psi_j(t) \left[ e^{ \left( \frac{E_j - E_i}{\hbar} - \omega \right) t} + e^{ \left( \frac{E_i - E_j}{\hbar} - \omega \right) t} \right] T_{ij}. \]</span></p>
<p>In the second half of the equation, I used the <a href="https://en.wikipedia.org/wiki/Euler%27s_formula">Euler’s formula</a> to rewrite cosine as a complex exponential and defined the transition matrix <span class="math inline">\(T_{ij} \equiv \left&lt; \phi_i \right| \hat{H}_1 \left| \phi_j \right&gt;\)</span>. This matrix describes how the different states couple to each other through the action of the oscillating magnetic field. One way to put this into code would be like this:</p>
<div class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">H1</span>(bac)</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    gS <span class="op">=</span> <span class="op">-</span><span class="fl">2.00231930436</span>; <span class="co"># Electron g-factor</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    gI <span class="op">=</span> <span class="fl">0.0009951414</span>; <span class="co"># Nuclear g-factor</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    gL <span class="op">=</span> <span class="op">-</span><span class="fl">0.99999369</span>; <span class="co"># Electron orbital g-factor</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>    μB <span class="op">=</span> <span class="fl">1.3996245</span>; <span class="co"># Bohr magneton in ħ*MHz/G</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># AC magnetic field components</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>    bx <span class="op">=</span> bac[<span class="fl">1</span>];</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>    by <span class="op">=</span> bac[<span class="fl">2</span>];</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>    bz <span class="op">=</span> bac[<span class="fl">3</span>];</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Nuclear spin</span></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>    Ix <span class="op">=</span> <span class="fu">kron</span>(<span class="fu">sx</span>(<span class="fl">3</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">0</span>));</span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>    Iy <span class="op">=</span> <span class="fu">kron</span>(<span class="fu">sy</span>(<span class="fl">3</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">0</span>));</span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>    Iz <span class="op">=</span> <span class="fu">kron</span>(<span class="fu">sz</span>(<span class="fl">3</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">0</span>));</span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Electron spin</span></span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a>    Sx <span class="op">=</span> <span class="fu">kron</span>(<span class="fu">sid</span>(<span class="fl">3</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sx</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">0</span>));</span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a>    Sy <span class="op">=</span> <span class="fu">kron</span>(<span class="fu">sid</span>(<span class="fl">3</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sy</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">0</span>));</span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a>    Sz <span class="op">=</span> <span class="fu">kron</span>(<span class="fu">sid</span>(<span class="fl">3</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sz</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">0</span>));</span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Electron angular momentum</span></span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a>    Lx <span class="op">=</span> <span class="fu">kron</span>(<span class="fu">sid</span>(<span class="fl">3</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sx</span>(<span class="fl">0</span>));</span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>    Ly <span class="op">=</span> <span class="fu">kron</span>(<span class="fu">sid</span>(<span class="fl">3</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sy</span>(<span class="fl">0</span>));</span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a>    Lz <span class="op">=</span> <span class="fu">kron</span>(<span class="fu">sid</span>(<span class="fl">3</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sid</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>), <span class="fu">sz</span>(<span class="fl">0</span>));</span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a>    sb <span class="op">=</span> @. gS <span class="op">*</span> (bx <span class="op">*</span> Sx <span class="op">+</span> by <span class="op">*</span> Sy <span class="op">+</span> bz <span class="op">*</span> Sz);</span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a>    ib <span class="op">=</span> @. gI <span class="op">*</span> (bx <span class="op">*</span> Ix <span class="op">+</span> by <span class="op">*</span> Iy <span class="op">+</span> bz <span class="op">*</span> Iz);</span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a>    lb <span class="op">=</span> @. gL <span class="op">*</span> (bx <span class="op">*</span> Lx <span class="op">+</span> by <span class="op">*</span> Ly <span class="op">+</span> bz <span class="op">*</span> Lz);</span>
<span id="cb32-28"><a href="#cb32-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-29"><a href="#cb32-29" aria-hidden="true" tabindex="-1"></a>    @. <span class="op">-</span>μB <span class="op">*</span> (sb <span class="op">+</span> ib <span class="op">+</span> lb) </span>
<span id="cb32-30"><a href="#cb32-30" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb32-31"><a href="#cb32-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-32"><a href="#cb32-32" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">T</span>(bdc, bac)</span>
<span id="cb32-33"><a href="#cb32-33" aria-hidden="true" tabindex="-1"></a>    evs <span class="op">=</span> <span class="fu">eigvecs</span>(<span class="fu">H0</span>(bdc))</span>
<span id="cb32-34"><a href="#cb32-34" aria-hidden="true" tabindex="-1"></a>    <span class="fu">transpose</span>(evs) <span class="op">*</span> <span class="fu">H1</span>(bac) <span class="op">*</span> evs</span>
<span id="cb32-35"><a href="#cb32-35" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb32-36"><a href="#cb32-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-37"><a href="#cb32-37" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">Hij</span>(ω, t, bdc, bac)</span>
<span id="cb32-38"><a href="#cb32-38" aria-hidden="true" tabindex="-1"></a>    hbar <span class="op">=</span> <span class="fl">1</span><span class="op">/</span>(<span class="fl">2</span><span class="op">*</span><span class="cn">π</span>)</span>
<span id="cb32-39"><a href="#cb32-39" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-40"><a href="#cb32-40" aria-hidden="true" tabindex="-1"></a>    es <span class="op">=</span> <span class="fu">eigvals</span>(<span class="fu">H0</span>(bdc))</span>
<span id="cb32-41"><a href="#cb32-41" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="fu">length</span>(es)</span>
<span id="cb32-42"><a href="#cb32-42" aria-hidden="true" tabindex="-1"></a>    <span class="fu">δE</span>(i, j) <span class="op">=</span> ((es[i] <span class="op">-</span> es[j]) <span class="op">/</span> hbar <span class="op">-</span> ω) <span class="op">*</span> t</span>
<span id="cb32-43"><a href="#cb32-43" aria-hidden="true" tabindex="-1"></a>    mat <span class="op">=</span> [<span class="fu">exp</span>(<span class="op">-</span><span class="fl">1im</span> <span class="op">*</span> <span class="fu">δE</span>(j, i)) <span class="op">+</span> <span class="fu">exp</span>(<span class="fl">1im</span> <span class="op">*</span> <span class="fu">δE</span>(i, j)) for i <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>n, j <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>n] <span class="op">.*</span> <span class="fu">T</span>(bdc, bac)</span>
<span id="cb32-44"><a href="#cb32-44" aria-hidden="true" tabindex="-1"></a>    @. mat <span class="op">/</span> <span class="fl">1im</span> <span class="op">/</span> hbar <span class="op">/</span> <span class="fl">2.0</span></span>
<span id="cb32-45"><a href="#cb32-45" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The matrix <code>Hij</code> absorbs all the constants, so that the differential equation can be written as <span class="math inline">\(\frac{d}{dt}\vec{\psi}(t) = H_{ij} \cdot \vec{\psi}(t)\)</span> - this makes the code a little bit more legible when we feed it to the ODE solver.</p>
<p>Speaking of solvers, now is the time to discuss some performance considerations and profiling. No matter what library you use, the main part of what the solver is going to do is discretize the time and repeatedly apply the operator <code>Hij</code> to the solution vector (or initial condition) <code>psi</code> (<code>psi0</code>). The time step needs to be small and the number of operator applications will be big, easily tens of thousands, so you want the evaluation of the function <code>Hij</code> to be fast. To check how fast does a code run in Julia, you can use the <code>@time</code> macro. Because of the JIT compilation, it will be slow the first time you evaluate a function, so I recommend doing it at least twice to avoid timing also the compilation step. When we check the speed of our first attempt</p>
<div class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="pp">@time</span> <span class="fu">Hij</span>(<span class="fl">1000</span>, <span class="fl">0.1</span>, <span class="fl">4</span>, [<span class="fl">0.1</span>; <span class="fl">0</span>; <span class="fl">0</span>]);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  0.000164 seconds (368 allocations: 107.438 KiB)</code></pre>
</div>
</div>
<p>We see that it takes ~160 us to run - not good. The number of memory allocations is bad too. When it takes 368 allocations to calculate the components of a 8x8 matrix, you usually know something went wrong.</p>
<p>Julia achieves it’s high performance by (among other things) aggressively monomorphizing functions through <a href="https://en.wikipedia.org/wiki/Multiple_dispatch#Julia">multiple dispatch</a>. This means that if you have a generic function <code>f(x)</code>, it compiles down to machine code that’s separate for each type of <code>x</code> used, i.e.&nbsp;<code>f(x::Int64)</code> and <code>f(x::Float64)</code> can have two different definitions and, even if they don’t, things like basic arithmetic dispatches too, so they will become separate functions under the hood. But if the compiler cannot infer the type of your variables at compile-time, or the types might change (<a href="https://discourse.julialang.org/t/why-type-instability/4013">type instability</a>), it has to fall back on abstract types, which will cause a lot of allocations and inhibit a lot of optimization steps. In a dynamic language like Julia, type instability is hard to avoid and sometimes doesn’t really matter, but you should do your best to get rid of it in performance-critical parts. To check for this problem, there’s another macro called <code>@code_warntype</code>, which will print the inferred types (or lack thereof):</p>
<div class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="pp">@code_warntype</span> <span class="fu">Hij</span>(<span class="fl">1000</span>, <span class="fl">0.1</span>, <span class="fl">4</span>, [<span class="fl">0.1</span>; <span class="fl">0</span>; <span class="fl">0</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Variables
  #self#::Core.Compiler.Const(Hij, false)
  ω::Int64
  t::Float64
  bdc::Int64
  bac::Array{Float64,1}
  #9::getfield(Main, Symbol("##9#11")){_A} where _A
  hbar::Float64
  es::Union{Array{Complex{Float64},1}, Array{Float64,1}}
  n::Int64
  δE::getfield(Main, Symbol("#δE#10")){Int64,Float64,Float64,_A} where _A
  mat::Any

Body::Any
1 ─ %1  = (2 * Main.π)::Core.Compiler.Const(6.283185307179586, false)
│         (hbar = 1 / %1)
│   %3  = Main.H0(bdc)::Array{Complex{Float64},2}
│         (es = Main.eigvals(%3))
│         (n = Main.length(es))
│   %6  = Main.:(#δE#10)::Core.Compiler.Const(getfield(Main, Symbol("#δE#10")), false)
│   %7  = Core.typeof(ω)::Core.Compiler.Const(Int64, false)
│   %8  = Core.typeof(t)::Core.Compiler.Const(Float64, false)
│   %9  = Core.typeof(hbar::Core.Compiler.Const(0.15915494309189535, false))::Core.Compiler.Const(Float64, false)
│   %10 = Core.typeof(es)::Union{Type{Array{Complex{Float64},1}}, Type{Array{Float64,1}}}
│   %11 = Core.apply_type(%6, %7, %8, %9, %10)::Type{getfield(Main, Symbol("#δE#10")){Int64,Float64,Float64,_A}} where _A
│   %12 = hbar::Core.Compiler.Const(0.15915494309189535, false)::Core.Compiler.Const(0.15915494309189535, false)
│         (δE = %new(%11, ω, t, %12, es))
│   %14 = Main.:(##9#11)::Core.Compiler.Const(getfield(Main, Symbol("##9#11")), false)
│   %15 = Core.typeof(δE)::Type{getfield(Main, Symbol("#δE#10")){Int64,Float64,Float64,_A}} where _A
│   %16 = Core.apply_type(%14, %15)::Type{getfield(Main, Symbol("##9#11")){_A}} where _A
│         (#9 = %new(%16, δE))
│   %18 = #9::getfield(Main, Symbol("##9#11")){_A} where _A
│   %19 = (1:n)::Core.Compiler.PartialStruct(UnitRange{Int64}, Any[Core.Compiler.Const(1, false), Int64])
│   %20 = (1:n)::Core.Compiler.PartialStruct(UnitRange{Int64}, Any[Core.Compiler.Const(1, false), Int64])
│   %21 = Base.product(%19, %20)::Core.Compiler.PartialStruct(Base.Iterators.ProductIterator{Tuple{UnitRange{Int64},UnitRange{Int64}}}, Any[Core.Compiler.PartialStruct(Tuple{UnitRange{Int64},UnitRange{Int64}}, Any[Core.Compiler.PartialStruct(UnitRange{Int64}, Any[Core.Compiler.Const(1, false), Int64]), Core.Compiler.PartialStruct(UnitRange{Int64}, Any[Core.Compiler.Const(1, false), Int64])])])
│   %22 = Base.Generator(%18, %21)::Base.Generator{Base.Iterators.ProductIterator{Tuple{UnitRange{Int64},UnitRange{Int64}}},_A} where _A
│   %23 = Base.collect(%22)::Array{_A,2} where _A
│   %24 = Main.T(bdc, bac)::Any
│   %25 = Base.broadcasted(Main.:*, %23, %24)::Any
│         (mat = Base.materialize(%25))
│   %27 = mat::Any
│   %28 = Base.broadcasted(Main.:*, 1, Main.im)::Core.Compiler.Const(Base.Broadcast.Broadcasted(*, (1, im)), false)
│   %29 = Base.broadcasted(Main.:/, %27, %28)::Any
│   %30 = Base.broadcasted(Main.:/, %29, hbar::Core.Compiler.Const(0.15915494309189535, false))::Any
│   %31 = Base.broadcasted(Main.:/, %30, 2.0)::Any
│   %32 = Base.materialize(%31)::Any
└──       return %32</code></pre>
</div>
</div>
<p>It looks a bit scary, but most of it is not that important to understand. What <em>is</em> important to understand is that red text = bad and that most of the critical information is in the header called “Variables”. You see that the problematic variables are <code>#9</code> (which is a unnamed variable), <code>es</code>, <code>δE</code>, <code>mat</code> and then also the body (but that’s because of the failed inference that happened beforehand). For example, <code>es::Union{Array{Complex{Float64},1}, Array{Float64,1}}</code> means that the eigenvalues <code>es</code> can be either an array of complex or floating point numbers, which is not surprising, because the function <code>eigvals</code> can realistically produce either as a valid output. The next problematic part is <code>#9::getfield(Main, Symbol("##9#11")){_A} where _A</code>, which is (I think) related to the transition matrix function call <code>T(bdc, bac)</code> where it cannot determine what type the output is. Because of these two, it fails the inference for the output type of the inline function <code>δE(i, j) = ((es[i] - es[j]) / hbar - ω) * t</code> and the output matrix <code>mat</code>, which screws up the whole body of the function call.</p>
<p>To solve this, we can pre-calculate certain variables and pass them in as arguments to <code>Hij</code>, which will kill two birds with one stone. The first is the time spent doing useless calculation: The energy eigenvalues of <span class="math inline">\(\hat{H}_0\)</span> don’t change because <span class="math inline">\(\hat{H}_0\)</span> doesn’t depend on time and neither does the transition matrix, which depends only on the polarization of the EM wave. And yet, they take the most computational time, because you need to do eigendecomposition of <span class="math inline">\(\hat{H}_0\)</span> to get them, along with a bunch of computationally expensive matrix-matrix products. The other stoned bird is type instability where, by passing the eigenvalues and transition matrix as arguments, you make the compiler dispatch on their types and there’s no need for type inference within the function <code>Hij</code> anymore.</p>
<div class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">Hij_fast</span>(tij, es, ω, t, bdc, bac)</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    hbar <span class="op">=</span> <span class="fl">1</span><span class="op">/</span>(<span class="fl">2</span><span class="op">*</span><span class="cn">π</span>)</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="fu">length</span>(es)</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">δE</span>(i, j) <span class="op">=</span> ((es[i] <span class="op">-</span> es[j]) <span class="op">/</span> hbar <span class="op">-</span> ω) <span class="op">*</span> t</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>    mat <span class="op">=</span> [<span class="fu">exp</span>(<span class="op">-</span><span class="fl">1im</span> <span class="op">*</span> <span class="fu">δE</span>(j, i)) <span class="op">+</span> <span class="fu">exp</span>(<span class="fl">1im</span> <span class="op">*</span> <span class="fu">δE</span>(i, j)) for i <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>n, j <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>n] <span class="op">.*</span> tij</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>    @. mat <span class="op">/</span> <span class="fl">1im</span> <span class="op">/</span> hbar <span class="op">/</span> <span class="fl">2.0</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>tij <span class="op">=</span> <span class="fu">T</span>(<span class="fl">4</span>, [<span class="fl">0.1</span>; <span class="fl">0</span>; <span class="fl">0</span>])</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>es <span class="op">=</span> <span class="fu">eigvals</span>(<span class="fu">H0</span>(<span class="fl">4</span>))</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="pp">@time</span> <span class="fu">Hij_fast</span>(tij, es, <span class="fl">1000</span>, <span class="fl">0.1</span>, <span class="fl">4</span>, [<span class="fl">0.1</span>; <span class="fl">0</span>; <span class="fl">0</span>]);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  0.000012 seconds (15 allocations: 3.906 KiB)</code></pre>
</div>
</div>
<p>Much better. With the problematic parts pre-calculated first, it takes only ~12 us and 15 allocations to produce the operator <code>Hij</code>. The type instability is gone too:</p>
<div class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="pp">@code_warntype</span> <span class="fu">Hij_fast</span>(tij, es, <span class="fl">1000</span>, <span class="fl">0.1</span>, <span class="fl">4</span>, [<span class="fl">0.1</span>; <span class="fl">0</span>; <span class="fl">0</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Variables
  #self#::Core.Compiler.Const(Hij_fast, false)
  tij::Array{Complex{Float64},2}
  es::Array{Float64,1}
  ω::Int64
  t::Float64
  bdc::Int64
  bac::Array{Float64,1}
  #12::getfield(Main, Symbol("##12#14")){getfield(Main, Symbol("#δE#13")){Array{Float64,1},Int64,Float64,Float64}}
  hbar::Float64
  n::Int64
  δE::getfield(Main, Symbol("#δE#13")){Array{Float64,1},Int64,Float64,Float64}
  mat::Array{Complex{Float64},2}

Body::Array{Complex{Float64},2}
1 ─ %1  = (2 * Main.π)::Core.Compiler.Const(6.283185307179586, false)
│         (hbar = 1 / %1)
│         (n = Main.length(es))
│   %4  = Main.:(#δE#13)::Core.Compiler.Const(getfield(Main, Symbol("#δE#13")), false)
│   %5  = Core.typeof(es)::Core.Compiler.Const(Array{Float64,1}, false)
│   %6  = Core.typeof(ω)::Core.Compiler.Const(Int64, false)
│   %7  = Core.typeof(t)::Core.Compiler.Const(Float64, false)
│   %8  = Core.typeof(hbar::Core.Compiler.Const(0.15915494309189535, false))::Core.Compiler.Const(Float64, false)
│   %9  = Core.apply_type(%4, %5, %6, %7, %8)::Core.Compiler.Const(getfield(Main, Symbol("#δE#13")){Array{Float64,1},Int64,Float64,Float64}, false)
│         (δE = %new(%9, es, ω, t, hbar::Core.Compiler.Const(0.15915494309189535, false)))
│   %11 = Main.:(##12#14)::Core.Compiler.Const(getfield(Main, Symbol("##12#14")), false)
│   %12 = Core.typeof(δE::Core.Compiler.PartialStruct(getfield(Main, Symbol("#δE#13")){Array{Float64,1},Int64,Float64,Float64}, Any[Array{Float64,1}, Int64, Float64, Core.Compiler.Const(0.15915494309189535, false)]))::Core.Compiler.Const(getfield(Main, Symbol("#δE#13")){Array{Float64,1},Int64,Float64,Float64}, false)
│   %13 = Core.apply_type(%11, %12)::Core.Compiler.Const(getfield(Main, Symbol("##12#14")){getfield(Main, Symbol("#δE#13")){Array{Float64,1},Int64,Float64,Float64}}, false)
│         (#12 = %new(%13, δE::Core.Compiler.PartialStruct(getfield(Main, Symbol("#δE#13")){Array{Float64,1},Int64,Float64,Float64}, Any[Array{Float64,1}, Int64, Float64, Core.Compiler.Const(0.15915494309189535, false)])))
│   %15 = #12::Core.Compiler.PartialStruct(getfield(Main, Symbol("##12#14")){getfield(Main, Symbol("#δE#13")){Array{Float64,1},Int64,Float64,Float64}}, Any[Core.Compiler.PartialStruct(getfield(Main, Symbol("#δE#13")){Array{Float64,1},Int64,Float64,Float64}, Any[Array{Float64,1}, Int64, Float64, Core.Compiler.Const(0.15915494309189535, false)])])::Core.Compiler.PartialStruct(getfield(Main, Symbol("##12#14")){getfield(Main, Symbol("#δE#13")){Array{Float64,1},Int64,Float64,Float64}}, Any[Core.Compiler.PartialStruct(getfield(Main, Symbol("#δE#13")){Array{Float64,1},Int64,Float64,Float64}, Any[Array{Float64,1}, Int64, Float64, Core.Compiler.Const(0.15915494309189535, false)])])
│   %16 = (1:n)::Core.Compiler.PartialStruct(UnitRange{Int64}, Any[Core.Compiler.Const(1, false), Int64])
│   %17 = (1:n)::Core.Compiler.PartialStruct(UnitRange{Int64}, Any[Core.Compiler.Const(1, false), Int64])
│   %18 = Base.product(%16, %17)::Core.Compiler.PartialStruct(Base.Iterators.ProductIterator{Tuple{UnitRange{Int64},UnitRange{Int64}}}, Any[Core.Compiler.PartialStruct(Tuple{UnitRange{Int64},UnitRange{Int64}}, Any[Core.Compiler.PartialStruct(UnitRange{Int64}, Any[Core.Compiler.Const(1, false), Int64]), Core.Compiler.PartialStruct(UnitRange{Int64}, Any[Core.Compiler.Const(1, false), Int64])])])
│   %19 = Base.Generator(%15, %18)::Core.Compiler.PartialStruct(Base.Generator{Base.Iterators.ProductIterator{Tuple{UnitRange{Int64},UnitRange{Int64}}},getfield(Main, Symbol("##12#14")){getfield(Main, Symbol("#δE#13")){Array{Float64,1},Int64,Float64,Float64}}}, Any[Core.Compiler.PartialStruct(getfield(Main, Symbol("##12#14")){getfield(Main, Symbol("#δE#13")){Array{Float64,1},Int64,Float64,Float64}}, Any[Core.Compiler.PartialStruct(getfield(Main, Symbol("#δE#13")){Array{Float64,1},Int64,Float64,Float64}, Any[Array{Float64,1}, Int64, Float64, Core.Compiler.Const(0.15915494309189535, false)])]), Core.Compiler.PartialStruct(Base.Iterators.ProductIterator{Tuple{UnitRange{Int64},UnitRange{Int64}}}, Any[Core.Compiler.PartialStruct(Tuple{UnitRange{Int64},UnitRange{Int64}}, Any[Core.Compiler.PartialStruct(UnitRange{Int64}, Any[Core.Compiler.Const(1, false), Int64]), Core.Compiler.PartialStruct(UnitRange{Int64}, Any[Core.Compiler.Const(1, false), Int64])])])])
│   %20 = Base.collect(%19)::Array{Complex{Float64},2}
│   %21 = Base.broadcasted(Main.:*, %20, tij)::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{2},Nothing,typeof(*),Tuple{Array{Complex{Float64},2},Array{Complex{Float64},2}}}
│         (mat = Base.materialize(%21))
│   %23 = mat::Array{Complex{Float64},2}
│   %24 = Base.broadcasted(Main.:*, 1, Main.im)::Core.Compiler.Const(Base.Broadcast.Broadcasted(*, (1, im)), false)
│   %25 = Base.broadcasted(Main.:/, %23, %24)::Core.Compiler.PartialStruct(Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{2},Nothing,typeof(/),Tuple{Array{Complex{Float64},2},Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{0},Nothing,typeof(*),Tuple{Int64,Complex{Bool}}}}}, Any[Core.Compiler.Const(/, false), Core.Compiler.PartialStruct(Tuple{Array{Complex{Float64},2},Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{0},Nothing,typeof(*),Tuple{Int64,Complex{Bool}}}}, Any[Array{Complex{Float64},2}, Core.Compiler.Const(Base.Broadcast.Broadcasted(*, (1, im)), false)]), Core.Compiler.Const(nothing, false)])
│   %26 = Base.broadcasted(Main.:/, %25, hbar::Core.Compiler.Const(0.15915494309189535, false))::Core.Compiler.PartialStruct(Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{2},Nothing,typeof(/),Tuple{Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{2},Nothing,typeof(/),Tuple{Array{Complex{Float64},2},Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{0},Nothing,typeof(*),Tuple{Int64,Complex{Bool}}}}},Float64}}, Any[Core.Compiler.Const(/, false), Core.Compiler.PartialStruct(Tuple{Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{2},Nothing,typeof(/),Tuple{Array{Complex{Float64},2},Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{0},Nothing,typeof(*),Tuple{Int64,Complex{Bool}}}}},Float64}, Any[Core.Compiler.PartialStruct(Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{2},Nothing,typeof(/),Tuple{Array{Complex{Float64},2},Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{0},Nothing,typeof(*),Tuple{Int64,Complex{Bool}}}}}, Any[Core.Compiler.Const(/, false), Core.Compiler.PartialStruct(Tuple{Array{Complex{Float64},2},Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{0},Nothing,typeof(*),Tuple{Int64,Complex{Bool}}}}, Any[Array{Complex{Float64},2}, Core.Compiler.Const(Base.Broadcast.Broadcasted(*, (1, im)), false)]), Core.Compiler.Const(nothing, false)]), Core.Compiler.Const(0.15915494309189535, false)]), Core.Compiler.Const(nothing, false)])
│   %27 = Base.broadcasted(Main.:/, %26, 2.0)::Core.Compiler.PartialStruct(Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{2},Nothing,typeof(/),Tuple{Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{2},Nothing,typeof(/),Tuple{Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{2},Nothing,typeof(/),Tuple{Array{Complex{Float64},2},Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{0},Nothing,typeof(*),Tuple{Int64,Complex{Bool}}}}},Float64}},Float64}}, Any[Core.Compiler.Const(/, false), Core.Compiler.PartialStruct(Tuple{Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{2},Nothing,typeof(/),Tuple{Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{2},Nothing,typeof(/),Tuple{Array{Complex{Float64},2},Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{0},Nothing,typeof(*),Tuple{Int64,Complex{Bool}}}}},Float64}},Float64}, Any[Core.Compiler.PartialStruct(Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{2},Nothing,typeof(/),Tuple{Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{2},Nothing,typeof(/),Tuple{Array{Complex{Float64},2},Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{0},Nothing,typeof(*),Tuple{Int64,Complex{Bool}}}}},Float64}}, Any[Core.Compiler.Const(/, false), Core.Compiler.PartialStruct(Tuple{Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{2},Nothing,typeof(/),Tuple{Array{Complex{Float64},2},Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{0},Nothing,typeof(*),Tuple{Int64,Complex{Bool}}}}},Float64}, Any[Core.Compiler.PartialStruct(Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{2},Nothing,typeof(/),Tuple{Array{Complex{Float64},2},Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{0},Nothing,typeof(*),Tuple{Int64,Complex{Bool}}}}}, Any[Core.Compiler.Const(/, false), Core.Compiler.PartialStruct(Tuple{Array{Complex{Float64},2},Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{0},Nothing,typeof(*),Tuple{Int64,Complex{Bool}}}}, Any[Array{Complex{Float64},2}, Core.Compiler.Const(Base.Broadcast.Broadcasted(*, (1, im)), false)]), Core.Compiler.Const(nothing, false)]), Core.Compiler.Const(0.15915494309189535, false)]), Core.Compiler.Const(nothing, false)]), Core.Compiler.Const(2.0, false)]), Core.Compiler.Const(nothing, false)])
│   %28 = Base.materialize(%27)::Array{Complex{Float64},2}
└──       return %28</code></pre>
</div>
</div>
<p>There’s no red text anywhere and the compiler is able to infer all types at compile-time.</p>
<p>Now we can get to solve the (set of) differential equations. Many of you probably did make your own Euler and Runge-Kutta solvers or had to deal with libraries like <a href="https://computing.llnl.gov/projects/sundials">SUNDIALS</a>, so you know how much of a pain can this be. Fortunately, Julia has a nifty package called <a href="https://github.com/JuliaDiffEq/DifferentialEquations.jl">DifferentialEquations.jl</a> that makes this a very straightforward procedure. There’s a lot of bells and whistles and related libraries that you can play with, but in it’s most basic form, the library solves ODEs of the form <span class="math inline">\(\dot{u}(t) = f(u(t),t)\)</span>.</p>
<p>First you need to define your problem which is done by defining the right-hand-side of the ODE, either directly as <code>f(u, p, t)</code>, or the in-place update <code>f(du, u, p, t)</code>, where the output is stored in the mutable variable <code>du</code> (to save some allocations). The function <code>f</code> is in my case called <code>schr_eq</code> and as variables it takes the new time state <span class="math inline">\(\vec{\psi}(t + dt)\)</span> in <code>du</code>, the current state <span class="math inline">\(\vec{\psi}(t)\)</span> in <code>u</code>, all the parameters stored in an array <code>p</code> and the current time <code>t</code>. The whole thing gets packaged into a <code>ODEProblem</code> along with the initial condition <code>psi0</code> and a tuple of initial and final time <code>tspan</code> and solving the differential system is as easy as calling <code>solve()</code>. In general, it attempts to do some heuristics to determine the optimal solving algorithm but, for some reason, it fails to do that properly with this specific problem (complex arrays throw it off) so I had to manually chose the <code>Tsit5()</code> algorithm (seems to be the default).</p>
<div class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">schr_eq</span>(du, u, p, t)</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>    ω, bz, bac, es, tij <span class="op">=</span> p</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>    du[<span class="op">:</span>] <span class="op">=</span> <span class="fu">Hij_fast</span>(tij, es, ω, t, bz, bac) <span class="op">*</span> u</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">solve_schr_eq</span>(ω, tmax, bz, bac, psi0)</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>    es <span class="op">=</span> <span class="fu">eigvals</span>(<span class="fu">H0</span>(bz))</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>    tij <span class="op">=</span> <span class="fu">T</span>(bz, bac)</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>    tspan <span class="op">=</span> (<span class="fl">0</span>., tmax)</span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> [ω, bz, bac, es, tij]</span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>    prob <span class="op">=</span> <span class="fu">ODEProblem</span>(schr_eq, psi0, tspan, p)</span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>    <span class="fu">solve</span>(prob, <span class="fu">Tsit5</span>())</span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Trying it out should be as easy as defining the initial state, e.g.&nbsp;<span class="math inline">\(\psi(0)=\psi_1\)</span>, set up some values of fields and pressing the button:</p>
<div class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>Bz <span class="op">=</span> <span class="fl">3.22896</span> <span class="co"># Gauss</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>Bac <span class="op">=</span> [<span class="fl">0.1</span>, <span class="fl">0</span>, <span class="fl">0</span>] <span class="co"># Gauss</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>tmax <span class="op">=</span> <span class="fl">10.0</span> <span class="co"># μs</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>psi0 <span class="op">=</span> [<span class="fl">1.0</span><span class="op">+</span><span class="fl">0im</span>; <span class="fl">0.0</span>; <span class="fl">0.0</span>; <span class="fl">0.0</span>; <span class="fl">0.0</span>; <span class="fl">0.0</span>; <span class="fl">0.0</span>; <span class="fl">0.0</span>]</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>ω <span class="op">=</span> <span class="fl">1000</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>sol <span class="op">=</span> <span class="fu">solve_schr_eq</span>(ω, tmax, Bz, Bac, psi0);</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>() <span class="co"># Blank plot canvas</span></span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">8</span></span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">plot!</span>(<span class="fu">t-&gt;abs</span>(<span class="fu">sol</span>(t)[i])<span class="op">^</span><span class="fl">2</span>, <span class="fl">0</span>, tmax, label<span class="op">=</span><span class="st">"\$</span><span class="sc">\\</span><span class="st">psi_</span><span class="sc">$</span>i<span class="st">\$"</span>) <span class="co"># In-place update to add time trace of each state component to the plot</span></span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a><span class="fu">plot!</span>(ylabel<span class="op">=</span>L<span class="st">"\mathrm{\left| \psi </span><span class="sc">\r</span><span class="st">ight| ^2}"</span>)</span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a><span class="fu">plot!</span>(xlabel<span class="op">=</span>L<span class="st">"\mathrm{t [\mu s]}"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="29">
<p><img src="index_files/figure-html/cell-26-output-1.svg" class="img-fluid"></p>
</div>
</div>
<p>Isn’t that exciting? No? Tough crowd.</p>
<p>But really, nothing happens and one might even think that we did something wrong. Why? For two reasons: First, this is quantum mechanics and you cannot just change into a state with arbitrary energy. If we feed the system with energy of 1 GHz and there’s no allowed state 1 GHz above the ground-state, it will just sit there and ignore what we do because it there’s nowhere to put the energy in. Second, there are symmetry considerations and not every state can freely change into another, even if we give it a kick with the correct amount of energy. This information is hidden in the transition matrix elements, where you can see that some of them are equal to zero, which means that the states don’t couple. E.g. for the linearly polarized light:</p>
<div class="cell" data-execution_count="30">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="fu">T</span>(<span class="fl">1</span>, [<span class="fl">0.1</span>; <span class="fl">0</span>; <span class="fl">0</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="30">
<pre><code>8×8 Array{Complex{Float64},2}:
        0.0+0.0im  -0.0496596+0.0im  …        0.0+0.0im   0.121424+0.0im
 -0.0496596+0.0im         0.0+0.0im     0.0858776+0.0im        0.0+0.0im
        0.0+0.0im   0.0496698+0.0im           0.0+0.0im        0.0+0.0im
        0.0+0.0im         0.0+0.0im           0.0+0.0im        0.0+0.0im
        0.0+0.0im  -0.0858248+0.0im           0.0+0.0im        0.0+0.0im
 -0.0495408+0.0im         0.0+0.0im  …  0.0856718+0.0im        0.0+0.0im
        0.0+0.0im   0.0858776+0.0im           0.0+0.0im  0.0699364+0.0im
   0.121424+0.0im         0.0+0.0im     0.0699364+0.0im        0.0+0.0im</code></pre>
</div>
</div>
<p>You see that the ground-state doesn’t really couple to many others. You can try playing with this yourself and use different polarizations, like circular polarized light with <span class="math inline">\(\vec{B}_{ac} = B_x + iB_y\)</span> for example. However, there’s some coupling to the second excited state so let’s try to shine light that has frequency resonant with that transition:</p>
<div class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>Bz <span class="op">=</span> <span class="fl">3.22896</span> <span class="co"># Gauss</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>Bac <span class="op">=</span> [<span class="fl">0.1</span>; <span class="fl">0.0</span>; <span class="fl">0.0</span>] <span class="co"># Gauss</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>tmax <span class="op">=</span> <span class="fl">43.0</span> <span class="co"># μs</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>psi0 <span class="op">=</span> [<span class="fl">1.0</span><span class="op">+</span><span class="fl">0im</span>; <span class="fl">0.0</span>; <span class="fl">0.0</span>; <span class="fl">0.0</span>; <span class="fl">0.0</span>; <span class="fl">0.0</span>; <span class="fl">0.0</span>; <span class="fl">0.0</span>]</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>es <span class="op">=</span> <span class="fu">eigvals</span>(<span class="fu">H0</span>(Bz))</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>ω <span class="op">=</span> <span class="fl">2.0</span><span class="fu">*π*abs</span>(es[<span class="fl">1</span>] <span class="op">-</span> es[<span class="fl">2</span>])</span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>sol <span class="op">=</span> <span class="fu">solve_schr_eq</span>(ω, tmax, Bz, Bac, psi0);</span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>()</span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">8</span></span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>    <span class="fu">plot!</span>(<span class="fu">t-&gt;abs</span>(<span class="fu">sol</span>(t)[i])<span class="op">^</span><span class="fl">2</span>, <span class="fl">0</span>, tmax, label<span class="op">=</span><span class="st">"\$</span><span class="sc">\\</span><span class="st">psi_</span><span class="sc">$</span>i<span class="st">\$"</span>)</span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a><span class="fu">plot!</span>(ylabel<span class="op">=</span>L<span class="st">"\mathrm{\left| \psi </span><span class="sc">\r</span><span class="st">ight| ^2}"</span>)</span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a><span class="fu">plot!</span>(xlabel<span class="op">=</span>L<span class="st">"\mathrm{t [\mu s]}"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="31">
<p><img src="index_files/figure-html/cell-28-output-1.svg" class="img-fluid"></p>
</div>
</div>
<p>Beautiful, a good figure to end this post with. What’s happening here is that the atom is absorbing and emitting photons, moving between the ground and excited states, and the occupation of states <span class="math inline">\(\left| \psi_i \right| ^2\)</span> (probability to detect the electron in a given state) changes periodically in time as it does so. The states <span class="math inline">\(\psi_1\)</span> and <span class="math inline">\(\psi_3\)</span> are not directly coupled, but <span class="math inline">\(\psi_2\)</span> does couple to both and they are all close in energy, so the electron ends up sloshing between the three of them. Periodic occupancy changes between two states are called <a href="https://en.wikipedia.org/wiki/Rabi_cycle">Rabi oscillations</a>, which are used in EM cavities that are parts of many quantum information science experiments, for example <a href="https://www.nature.com/articles/s41586-019-1287-z">this one</a> (see <a href="https://www.quantamagazine.org/quantum-leaps-long-assumed-to-be-instantaneous-take-time-20190605/">this pop-sci article</a> if you don’t understand the publication itself). We will probably get back to this sometime in the future, if I decide to do a part on the <a href="https://en.wikipedia.org/wiki/Jaynes–Cummings_model">Jaynes-Cummings model</a>.</p>
<hr>
<p>That’s it for the first part of this series. We developed a basic method to solve static and dynamic quantum-mechanical problems and applied it to a simple real system. There are no hidden functions and all the dependencies can be downloaded directly in a running Julia session, so you need to download the packages as outlined at the beginning of this post and then you can just copy-paste the code as is and it will run. You can play around with it and try different physical parameters, different atoms (you’ll need to look up the coupling constants and nuclear/orbital spins configurations for a given atom) or try to rewrite it in your programming language of choice.</p>
<p>For the next part, I’m not yet sure if I’ll stick to spin systems, or if I’ll do something else and then come back to them in the future. But I have a couple of things in mind so, in the meantime, feel free to discuss and ask questions relating to anything that you’ve read here, I’m pretty sure that me or somebody else will be more than happy to answer the questions you have.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>