<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.335">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Tomas Polakovic">
<meta name="dcterms.date" content="2022-10-18">
<meta name="description" content="First delve into solid state physics: Crystals, symmetries, electronic bands. We explore basic computational methods, namelly the nearly free electron model and the tight binding method.">

<title>A Bit Correlated - Computational Physics for the Masses Part 3: Solid Stuff</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../favicon.ico" rel="icon">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="A Bit Correlated - Computational Physics for the Masses Part 3: Solid Stuff">
<meta property="og:description" content="First delve into solid state physics: Crystals, symmetries, electronic bands. We explore basic computational methods, namelly the nearly free electron model and the tight binding method.">
<meta property="og:image" content="https://tpolakovic.github.io/posts/cmpm3/thumbnail.png">
<meta property="og:site-name" content="A Bit Correlated">
<meta property="og:image:height" content="892">
<meta property="og:image:width" content="616">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">A Bit Correlated</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"><i class="bi bi-rss" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/tpolakovic/tpolakovic.github.io"><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Computational Physics for the Masses Part 3: Solid Stuff</h1>
                  <div>
        <div class="description">
          First delve into solid state physics: Crystals, symmetries, electronic bands. We explore basic computational methods, namelly the nearly free electron model and the tight binding method.
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Julia</div>
                <div class="quarto-category">Quantum mechanics</div>
                <div class="quarto-category">Solid state physics</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Tomas Polakovic </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">October 18, 2022</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>Guess who’s back? Yeah, it’s been a while, but I’ve been quite busy with…well, <em>things</em>. No matter; the show is going on and today we finally dive into “real” stuff in computational quantum mechanics, more specifically, solid state physics. This part will also be showing some more big-boy practices in programming, as today’s code will serve as a base for future parts of this series. It might mean that some parts will look a bit too verbose and not flow as nicely with the prose. But trust me, it will pay back in the future, so just follow along, there’s also numerical physics in this part. I promise.</p>
<hr>
<p>Real quick, let’s get the needed packages out of the way:</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">Pkg</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="bu">Pkg</span>.<span class="fu">activate</span>(<span class="st">"./env"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>  Activating project at `~/projects/website/posts/cmpm3/env`</code></pre>
</div>
</div>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Julia package environments
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>I start using package environments for individual parts of the series so that I don’t pollute my global package list with cruft that I don’t need outside of this blog. This is so that package versions can be resolved with minimal conflict and I avoid <a href="https://en.wikipedia.org/wiki/Dependency_hell">dependency hell</a> within my work.</p>
</div>
</div>
</div>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">LinearAlgebra</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">Unitful</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> <span class="bu">Unitful</span>: Å, eV</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">RangeHelpers</span>: range, around</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">Match</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">Colors</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">GLMakie</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>theme <span class="op">=</span> <span class="fu">Theme</span>(</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    Lines <span class="op">=</span> (color <span class="op">=</span> <span class="op">:</span>orangered2, cycle <span class="op">=</span> [],)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="fu">set_theme!</span>(theme)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Just dense linear algebra will carry us almost all the way today, so there’s not much in here. <code>Colors</code> contains some types and definitions for <code>GLMakie</code>, which is a backend for the <a href="http://makie.juliaplots.org/stable/">Makie</a> plotting package that I got to like more than <code>Plots.jl</code> (there are a few lines at the bottom so that the default colors fit the theme of the blog, you can safely skip those). <code>Unitful</code> is a package to use and transform physical units and <code>RangeHelpers</code> gives a few quality-of-life improvements to linear <code>range</code>s found in the standard library.</p>
<section id="sec-cmpm3-groups" class="level3">
<h3 class="anchored" data-anchor-id="sec-cmpm3-groups">On <del>life</del>, groups and crystals</h3>
<p>Before I go to the nitty-gritty of solids, I’ll make a short mathematical digression on group theory (something that’s very useful in physics and chemistry, so it’s worth talking about whenever possible).</p>
<p>The definition of a group is, as with many fundamental things in mathematics, a bit hazy to a layperson: A group is a set of…<em>some things</em> and operations on these things that transform the things from the group into other things of the same group. The operations should be <a href="https://en.wikipedia.org/wiki/Associative_property">associative</a> and for a bunch of things to be considered a group, they need to include a <a href="https://en.wikipedia.org/wiki/Identity_element">neutral thing</a> and all somethings need to have their corresponding <a href="https://en.wikipedia.org/wiki/Inverse_element">inverse things</a> in the group, too. Confusing? Good, that’s how you know it’s important.</p>
<p>And why is it important to us? Well, turns out that most solids are (at least in the ideal case) crystals, and most crystals form something called point symmetry groups. A point symmetry group is a collection of points in some kind of decently well-behaved space and some symmetry operations that “move” the points from their original positions into positions of other points without changing the overall structure.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="lattice-translation.png" class="img-fluid figure-img" style="width:90.0%"></p>
</figure>
</div>
<p>Take, for example, a crystal that sits on a square lattice, like the two in the above picture. Pick a vector between two arbitrary points on the lattice (orange arrows), grab every single thing sitting on the lattice point (black dots), and move it by the same vector (black arrows). You see that if you do it to every thing on the (infinitely large) lattice, they will end up still sitting on the same lattice. This is known as (discrete) translational symmetry and the displacement vectors that preserve the shape of the crystal are known as lattice translation vectors. You can similarly rotate the whole crystal around any of the lattice points by, e.g., 90º and end up with the same thing (n-fold rotational symmetry, where n is the number of rotations you can do before you go full circle) or you can reflect across a line connecting any of the nearest neighbors (reflection symmetry). You can stack these operations in any way you want, and the resulting crystal will still look the same.</p>
<p>From this, the old-timey definition of a crystal was that it is a periodic structure, i.e.&nbsp;a collection of atoms whose positions could transform into each other by translating along a lattice vector, like the orange one above. The definition had to change a couple of decades ago with Shechtman’s (in)famous discovery of naturally occurring stable <a href="https://en.wikipedia.org/wiki/Quasicrystal">quasicrystals</a>, where now a crystal is any structure with a discrete Fourier transform (reason for that will become obvious as we delve deeper into solid state and condensed matter physics).</p>
<p>If we stick to just periodic structures, it turns out that there is only a finite amount of groups that work with this definition. To be more exact, there are only 5 of them in 2D and 14 in 3D space, and we call them <a href="https://en.wikipedia.org/wiki/Bravais_lattice">Bravais lattices</a>. The more perceptive of you should notice that such a small number of space groups cannot account for the whole zoo of crystal structures found in nature. That is because the thing that’s periodic with the lattice does not need to be just a single atom. In most crystals, you actually have clumps of atoms and these clumps repeat periodically. The volume that contains this repeating pattern or clump is called the unit cell. By demanding that these unit cells need always fill the space without any gap, you end up with 7 <a href="https://en.wikipedia.org/wiki/Crystal_system">crystal systems</a> and the whole shebang leads to a grand total of 230 possible crystal symmetries, which form the <a href="https://en.wikipedia.org/wiki/Space_group">crystallographic space groups</a>.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>There is quite a bit more to be said about how symmetries dictate physics and how you can get a rather good qualitative understanding of a material and its chemistry just from the space symmetry of the lattice or molecule. As a matter of fact, there are <a href="https://link.springer.com/book/10.1007/978-3-642-97029-0">whole books</a> dedicated to this topic, which is why I won’t go that deep into it right now. It’s much better from the engagement standpoint to just sprinkle bits and pieces in as they become relevant.</p>
<p>That, and the author of this blog is really bad at crystallography, so he needs to change the topic. Fast.</p>
<p>So the first thing on our way toward calculations on crystals is implementing the lattice. But before that: units! We’ll use a form of atomic unit system called the <a href="https://en.wikipedia.org/wiki/Hartree_atomic_units">Hartree unit system</a>, which sets basically every unitful property of the hydrogen atom equal to one: <span class="math inline">\(m_e = e = \hbar = a_0 = 1\)</span> (<span class="math inline">\(a_0\)</span> is the Bohr radius). The characteristic scale of energy in this system is called Hartree (Ha) and corresponds to the total electrostatic energy of a Hydrogen atom which, by the virial theorem, is twice the ionization energy or ~27 eV. Bohr radii are not exactly convenient to work with in diffraction experiments and most people use nanometers or angstroms and electronvolts, so let’s handle that:</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>a₀ <span class="op">=</span> <span class="fl">0.529177249</span>Å</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>Ha <span class="op">=</span> <span class="fl">27.2</span>eV;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Note
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p><code>Unitful</code> already has angstroms and electronvolts defined, so there’s nothing more needed.</p>
</div>
</div>
</div>
<p>Now we can define a Bravais lattice type, which is uniquely determined in <span class="math inline">\(d\)</span>-dimensional space by a set of <span class="math inline">\(d\)</span> independent primitive lattice translation vectors <span class="math inline">\(\{ R_i \}_{i = 1} ^d\)</span>. The whole lattice is a linear combination of those, i.e.&nbsp;<span class="math inline">\(\vec{R}_{ n= \{ n_i \}} = \sum_{i=1}^d n_i \vec{R}_i\)</span> (<span class="math inline">\(n_i\)</span> is the index of individual lattice sites).</p>
<p>In anticipation of what’s to come, I’ll also package it with a corresponding <a href="https://en.wikipedia.org/wiki/Reciprocal_lattice">reciprocal lattice</a>, which is a dual lattice to the real-space lattice (think the correspondence of momentum space and real space). Many textbooks introduce this lattice in the context of diffraction experiments. There it turns out that X-rays or neutrons coherently scatter off the normal lattice only if their momentum/wave vector belongs to its reciprocal lattice, but I don’t like this approach. Because: a) it forces a full chapter of information on the realization of specific experimental techniques that has to be wedged into a much more physics-driven discussion, and b) because it’s first discussed in terms of experiments and little other context, it gives people the idea that the reciprocal lattice is a matter of experimental convenience, rather than a fundamental structure describing the physics.</p>
<p>So rather than going the conventional pedagogical route, I’ll incept the importance of the reciprocal lattice with definition using just the translational invariance. The rest will naturally fall into place as the discussion goes on.</p>
<p>Imagine a function of real-space coordinates that has the same symmetry as lattice, i.e.&nbsp;<span class="math inline">\(f(\vec{r} + \vec{R}_n) = f(\vec{r})\)</span> for any <span class="math inline">\(\vec{R}_n\)</span>. Basic Fourier analysis tells us that such a periodic function can be expanded using a discrete set of wave vectors <span class="math inline">\(\{ G_m \}\)</span>:</p>
<p><span class="math display">\[
f(\vec{r}) = \sum_m f_m e^{i \vec{G}_m \cdot \vec{r}} = \sum_m f_m e^{i \vec{G}_m \cdot (\vec{r} + \vec{R}_n)} = \sum_m f_m e^{i \vec{G}_m \cdot \vec{R}_n} e^{i \vec{G}_m \cdot \vec{r}}.
\]</span></p>
<p>This has to hold for arbitrary lattice vector <span class="math inline">\(\vec{R}_n\)</span>, so <span class="math inline">\(e^{i \vec{G}_m \cdot \vec{R}_n} = 1\)</span>. From this, the set of vectors <span class="math inline">\(\{ \vec{G}_m \}\)</span> is fully determined as:</p>
<p><span class="math display">\[
\vec{G}_m \cdot \vec{R}_n = 2\pi N; \; N \in \mathbb{Z}.
\]</span></p>
<p>Because the positions <span class="math inline">\(\vec{R}_n\)</span> form a lattice, the set of positions in momentum space <span class="math inline">\(\vec{G}_m\)</span> also forms a periodic structure. It’s not the same lattice but certain properties, e.g.&nbsp;rotational symmetries, are shared. And, as with its real-space dual, this lattice can be again uniquely determined by the primitive reciprocal vectors <span class="math inline">\(\{ \vec{G}_j \}_{j = 1}^d\)</span> defined by the above equation with <span class="math inline">\(\vec{R}_n\)</span> being the primitive lattice vectors and <span class="math inline">\(N = 1\)</span>.</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Lattice{T<span class="op">&lt;:</span><span class="dt">Real</span>, N}</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    R<span class="op">::</span><span class="dt">Union{T, Array{T}}</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    G<span class="op">::</span><span class="dt">Union{T, Array{T}}</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    V<span class="op">::</span><span class="dt">T</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">function</span> <span class="fu">Lattice</span>(R<span class="op">::</span><span class="dt">Union{&lt;:Real,Matrix{&lt;:Real}}</span>)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        G <span class="op">=</span> <span class="fl">2</span>π <span class="op">*</span> <span class="fu">inv</span>(R)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        R,G <span class="op">=</span> <span class="fu">promote</span>(R,G)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        V <span class="op">=</span> <span class="fu">det</span>(R)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        dim <span class="op">=</span> <span class="fu">isempty</span>(<span class="fu">size</span>(R)) ? <span class="fl">1</span> <span class="op">:</span> <span class="fu">first</span>(<span class="fu">size</span>(R))</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        <span class="fu">new</span><span class="dt">{eltype(R), dim}</span>(R, G, V)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">Lattice</span>(R<span class="op">::</span><span class="dt">Union{&lt;:Quantity, Matrix{&lt;:Quantity}}</span>)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    Unitful.<span class="fu">NoUnits</span>.(R <span class="op">./</span> a₀) <span class="op">|&gt;</span> Lattice</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">Lattice</span>(a<span class="op">::</span><span class="dt">T</span>, b<span class="op">::</span><span class="dt">T</span>, γ<span class="op">::</span><span class="dt">Real</span>) <span class="kw">where</span> T <span class="op">&lt;:</span><span class="dt"> Union{Real, Quantity}</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    γ <span class="op">=</span> <span class="fu">deg2rad</span>(γ)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    R <span class="op">=</span> [<span class="fu">a*sin</span>(γ) <span class="fu">zero</span>(T);</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>         <span class="fu">a*cos</span>(γ) b]</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">Lattice</span>(R)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">Lattice</span>(a<span class="op">::</span><span class="dt">T</span>, b<span class="op">::</span><span class="dt">T</span>, c<span class="op">::</span><span class="dt">T</span>, α<span class="op">::</span><span class="dt">Real</span>, β<span class="op">::</span><span class="dt">Real</span>, γ<span class="op">::</span><span class="dt">Real</span>) <span class="kw">where</span> T <span class="op">&lt;:</span><span class="dt"> Union{Real, Quantity}</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    α, β, γ <span class="op">=</span> <span class="fu">deg2rad</span>.((α, β, γ))</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    γ <span class="op">=</span> (<span class="fu">cos</span>(α) <span class="op">*</span> <span class="fu">cos</span>(β) <span class="op">-</span> <span class="fu">cos</span>(γ)) <span class="op">/</span> (<span class="fu">sin</span>(α) <span class="op">*</span> <span class="fu">sin</span>(β))</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    γ <span class="op">=</span> <span class="fu">clamp</span>(γ, <span class="op">-</span><span class="fl">1</span>, <span class="fl">1</span>) <span class="op">|&gt;</span> acos <span class="co"># floating point arithmetic could theoretically push the value above ±1</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    R <span class="op">=</span> [<span class="fu">a*sin</span>(β) <span class="fu">-b*sin</span>(α)<span class="fu">*cos</span>(γ) <span class="fu">zero</span>(T);</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>         <span class="fu">zero</span>(T)  <span class="fu">b*sin</span>(α)<span class="fu">*sin</span>(γ)  <span class="fu">zero</span>(T);</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>         <span class="fu">a*cos</span>(β) <span class="fu">b*cos</span>(α)         c]</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    <span class="fu">Lattice</span>(R)</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
About <code>Struct</code>s and constructors
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>A lot going on here. Because the notion of the lattice will come up time and time again, I created a <a href="https://docs.julialang.org/en/v1/manual/types/#Composite-Types">composite type</a> <code>Lattice</code>, which is a structure that holds the fields <code>R</code>, <code>G</code> and <code>V</code>. I also made it parametric over a restricted set of types, where <code>R</code> and <code>G</code> can be either of type <code>T</code> or an array of <code>T</code>s (that’s what the <code>Union</code> is for) and <code>T</code> has to be a subtype of real numbers (e.g.&nbsp;floats or integers). The option to have scalar <code>T</code> is because there’s no reason to pack a single number into an array if the lattice happens to be 1-dimensional. As to why I keep T so generic, there might be situations where we purposefully do not want it to be a 64-bit float. One such case is if I ever decide to also use this soon-to-be library for calculations on GPUs which often natively support only 32-bit floats (or we might want to use a symbolic type, <code>BigFloat</code>, etc.)</p>
<p>The next thing is <a href="https://docs.julialang.org/en/v1/manual/constructors/">constructors</a>, which come in two flavors. If you define a type <code>foo</code> with fields <code>bar</code> and <code>baz</code>, it will get a default constructor method <code>foo(bar, baz)</code>. But you might not want to do that, as in our case: The fields <code>G</code> and <code>V</code> are all determined by <code>R</code> and we want to enforce that relationship. That’s why I defined a function <code>Lattice(R)</code> inside the type definition, which overrides the default constructor. It has to return using the <code>new</code> method and now causes the original default constructor <code>Lattice(R, G, V)</code> to not exist - this is called an inner constructor. Then I use multiple dispatch to define more variations of constructors that all call the base one. First is a constructor that looks almost like the base, but it takes a type of <code>Quantity</code>, which is a unitful quantity (e.g.&nbsp;1 nm). It converts the quantity into a number (by scaling it to the Bohr radius) and feeds that to the base constructor. The other two constructors are convenience constructors, which build the matrix <code>R</code> out of <a href="https://en.wikipedia.org/wiki/Lattice_constant">lattice parameters</a> (and rotate the whole thing such that the last lattice vector is always parallel to the last cartesian axis). These are called outer constructors, for obvious reasons. They do not override or invalidate the default constructor unless you shadow it (define an outer constructor with the same type signature).</p>
</div>
</div>
</div>
<p>So why do I store the primitive vectors in matrices? First, it’s convenient. Second, it allows for a better representation of positions: In many cases, the primitive vectors do not form an orthogonal basis and mix cartesian coordinates (you’ll see concrete examples in a second). And many calculations or measurements are much easier to express in fractions of the lattice constants. So we’ll introduce <em>reduced</em> coordinates <span class="math inline">\(x_j\)</span>, that form an orthogonal system where the position vectors are fractions (or multiples) of the primitive vectors. The transformation of these reduced coordinates back to physical coordinates <span class="math inline">\(r_i\)</span> is the matrix <span class="math inline">\(R_{ij}\)</span>, i.e <span class="math inline">\(r_i = R_{ij} x_j\)</span> or <span class="math inline">\(\vec{r} = \mathbf{R} \vec{x}\)</span>. The same deal for reciprocal space vectors, although, one should keep in mind that the reciprocal vectors are covectors to real-space vectors. Strictly speaking, they should either be row vectors (we follow the normal-people convention of regular vectors being column vectors) and the matrix <span class="math inline">\(\mathbf{G}\)</span> multiplies them from the right, or the matrix has to be transposed. It is constructed by using the definition of reciprocal lattice, where <span class="math inline">\(\mathbf{R} \cdot \mathbf{G} = 2\pi \cdot \mathbf{1}\)</span>, which leads to <span class="math inline">\(\mathbf{G} = 2\pi \mathbf{R}^{-1}\)</span>. Then there’s also unit cell volume <code>V</code>.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<p>One last thing to mention here is that I also included the parameter <code>N</code>. It will be used to express the dimensionality of the lattice for multiple dispatch purposes, so I overload the <code>ndims</code> method for our <code>Lattice</code> type:</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="bu">Base</span>.<span class="fu">ndims</span>(l<span class="op">::</span><span class="dt">Lattice{T,N}</span>) <span class="kw">where</span> {T,N} <span class="op">=</span> N</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Our next step in the computational representation of the crystal is the unit cell, which is just a collection of site positions. That’s pretty straightforward:</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> UnitCell{T, N}</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    positions<span class="op">::</span><span class="dt">Vector{T}</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    species<span class="op">::</span><span class="dt">Vector{Symbol}</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">function</span> <span class="fu">UnitCell</span>(species<span class="op">::</span><span class="dt">Vector{Symbol}</span>, rs<span class="op">::</span><span class="dt">T...</span>) <span class="kw">where</span> T</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        positions <span class="op">=</span> <span class="fu">collect</span>(rs)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="fu">length</span>(species) <span class="op">==</span> <span class="fu">length</span>(rs)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>                <span class="fu">new</span><span class="dt">{T, length(first(rs))}</span>(positions, species)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>                <span class="fu">throw</span>(<span class="fu">DimensionMismatch</span>(<span class="st">"Number of species and positions does not match"</span>))</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">end</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">UnitCell</span>(species<span class="op">::</span><span class="dt">Symbol</span>, rs<span class="op">...</span>)</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    species <span class="op">=</span> <span class="fu">fill</span>(species, <span class="fu">length</span>(rs))</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    <span class="fu">UnitCell</span>(species, rs<span class="op">...</span>)</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">UnitCell</span>(rs<span class="op">...</span>)</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>    <span class="fu">UnitCell</span>(<span class="op">:</span>none, rs<span class="op">...</span>)</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>I follow the convention used in other similar software, where I also store the labels of the sites. For cases of the sites are identical or unlabeled, I provide convenience constructor methods. Note that the site positions are in <strong>reduced</strong> coordinates (an almost universally used convention). I again overload the dimensionality and length methods:</p>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="bu">Base</span>.<span class="fu">ndims</span>(c<span class="op">::</span><span class="dt">UnitCell{T,N}</span>) <span class="kw">where</span> {T,N} <span class="op">=</span> N</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="bu">Base</span>.<span class="fu">length</span>(c<span class="op">::</span><span class="dt">UnitCell</span>) <span class="op">=</span> c.positions <span class="op">|&gt;</span> length</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>With the Bravais lattice and unit cell being taken care of, we can finish our act of pure creation by defining the final <code>Crystal</code> type, which is just the repeating unit cell. To do that, we only need to package it together (the periodic repeating will be handled by the actual computational routines as necessary):</p>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Crystal{N}</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    lattice<span class="op">::</span><span class="dt">Lattice</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    cell<span class="op">::</span><span class="dt">UnitCell</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">function</span> <span class="fu">Crystal</span>(l<span class="op">::</span><span class="dt">Lattice{T,N}</span>, c<span class="op">::</span><span class="dt">UnitCell</span>) <span class="kw">where</span> {T,N}</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        <span class="fu">new</span><span class="dt">{N}</span>(l, c)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-4-contents" aria-controls="callout-4" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Note
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-4" class="callout-4-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Inner constructor here is to handle the type inference of the <a href="https://docs.julialang.org/en/v1/manual/types/#Parametric-Types">parametric type</a>.</p>
</div>
</div>
</div>
<p>To check if we did everything correctly, it would be nice to visualize the crystals. I guess the proper way would be to create a method that will export the information into some common file format and use proper crystallography tools (I use <a href="http://www.jp-minerals.org/vesta/en/">VESTA</a>), but that would require me to read through their specs. I’m not about to sink to such lows as following the fast and robust approach, so I’ll make my own visualization routine using <code>Makie</code> (blackjack and hookers not included):</p>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">plotcrystal!</span>(ax, c<span class="op">::</span><span class="dt">Crystal</span>, vertpos; ncells, showcell, showbonds, cmap)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    R <span class="op">=</span> c.lattice.R</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> showbonds</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> offset <span class="op">∈</span> <span class="bu">Iterators</span>.<span class="fu">product</span>(<span class="fu">fill</span>(<span class="fl">0</span><span class="op">:</span>(ncells<span class="op">-</span><span class="fl">1</span>), <span class="fu">ndims</span>(c.lattice))<span class="op">...</span>)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>            supercellpositions <span class="op">=</span> <span class="fu">eltype</span>(c.cell.positions)[]</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> pos <span class="op">∈</span> c.cell.positions</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> tn <span class="op">∈</span> <span class="bu">Iterators</span>.<span class="fu">product</span>(<span class="fu">fill</span>((<span class="op">-</span><span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">1</span>), <span class="fu">ndims</span>(c.lattice))<span class="op">...</span>)</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>                    <span class="fu">push!</span>(supercellpositions, R <span class="op">*</span> (pos <span class="op">.+</span> tn))</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>                <span class="cf">end</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">end</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> pos <span class="op">∈</span> c.cell.positions</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>                pos <span class="op">=</span> R <span class="op">*</span> pos</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>                rs <span class="op">=</span> <span class="fu">sort</span>(<span class="fu">map</span>(v <span class="op">-&gt;</span> v <span class="op">.-</span> pos, supercellpositions), by<span class="op">=</span>norm)</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>                <span class="fu">filter!</span>(v <span class="op">-&gt;</span> <span class="fu">norm</span>(v) <span class="op">&gt;</span> <span class="fl">0</span>, rs)</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>                nns <span class="op">=</span> <span class="fu">filter</span>(v <span class="op">-&gt;</span> <span class="fu">norm</span>(v) <span class="op">≈</span> <span class="fu">norm</span>(<span class="fu">first</span>(rs)), rs)</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> nn <span class="op">∈</span> nns</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>                    pos1 <span class="op">=</span> pos <span class="op">.+</span> R <span class="op">*</span> <span class="fu">collect</span>(offset)</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>                    pos2 <span class="op">=</span> pos <span class="op">.+</span> nn <span class="op">.+</span> R <span class="op">*</span> <span class="fu">collect</span>(offset)</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>                    <span class="fu">lines!</span>(ax, [<span class="fu">tuple</span>(pos1<span class="op">...</span>), <span class="fu">tuple</span>(pos2<span class="op">...</span>)], color<span class="op">=:</span>black, linewidth<span class="op">=</span><span class="fl">2</span>)</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>                <span class="cf">end</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">end</span></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> offset <span class="op">∈</span> <span class="bu">Iterators</span>.<span class="fu">product</span>(<span class="fu">fill</span>(<span class="fl">0</span><span class="op">:</span>(ncells<span class="op">-</span><span class="fl">1</span>), <span class="fu">ndims</span>(c.lattice))<span class="op">...</span>)</span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a>        sps <span class="op">=</span> <span class="fu">unique</span>(c.cell.species)</span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a>        nsps <span class="op">=</span> <span class="fu">length</span>(sps)</span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a>        cmap <span class="op">=</span> Makie.<span class="fu">categorical_colors</span>(cmap, nsps <span class="op">&gt;</span> <span class="fl">1</span> ? nsps <span class="op">:</span> <span class="fl">2</span>)</span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> showcell</span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a>            cellvertices <span class="op">=</span> <span class="fu">map</span>(v <span class="op">-&gt;</span> <span class="fu">tuple</span>((R <span class="op">*</span> (v <span class="op">.+</span> offset))<span class="op">...</span>), <span class="fu">eachcol</span>(vertpos))</span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a>            <span class="fu">lines!</span>(ax, cellvertices, color<span class="op">=:</span>grey, linewidth<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (i,sp) <span class="op">∈</span> <span class="fu">enumerate</span>(sps)</span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true" tabindex="-1"></a>            idxs <span class="op">=</span> <span class="fu">findall</span>(x <span class="op">-&gt;</span> x <span class="op">==</span> sp, c.cell.species)</span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true" tabindex="-1"></a>            pos <span class="op">=</span> [<span class="fu">tuple</span>((R <span class="op">*</span> (c.cell.positions[i] <span class="op">.+</span> offset))<span class="op">...</span>) for i <span class="op">∈</span> idxs]</span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true" tabindex="-1"></a>            <span class="fu">meshscatter!</span>(ax, pos, markersize<span class="op">=</span><span class="fl">0.5</span>, color<span class="op">=</span>cmap[i], shading<span class="op">=</span><span class="cn">true</span>, label<span class="op">=</span><span class="fu">string</span>(sp))</span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb12-42"><a href="#cb12-42" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-43"><a href="#cb12-43" aria-hidden="true" tabindex="-1"></a>    <span class="cn">nothing</span></span>
<span id="cb12-44"><a href="#cb12-44" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb12-45"><a href="#cb12-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-46"><a href="#cb12-46" aria-hidden="true" tabindex="-1"></a><span class="fu">plotcrystal!</span>(ax, c<span class="op">::</span><span class="dt">Crystal{2}</span>; ncells<span class="op">=</span><span class="fl">1</span>, showcell<span class="op">=</span><span class="cn">true</span>, showbonds<span class="op">=</span><span class="cn">true</span>, cmap<span class="op">=:</span>PuOr_5) <span class="op">=</span></span>
<span id="cb12-47"><a href="#cb12-47" aria-hidden="true" tabindex="-1"></a>    <span class="fu">plotcrystal!</span>(ax, c, [<span class="fl">0</span> <span class="fl">0</span> <span class="fl">1</span> <span class="fl">1</span> <span class="fl">0</span>; <span class="fl">0</span> <span class="fl">1</span> <span class="fl">1</span> <span class="fl">0</span> <span class="fl">0</span>]; ncells, showcell, showbonds, cmap<span class="op">=</span>cmap)</span>
<span id="cb12-48"><a href="#cb12-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-49"><a href="#cb12-49" aria-hidden="true" tabindex="-1"></a><span class="fu">plotcrystal!</span>(ax, c<span class="op">::</span><span class="dt">Crystal{3}</span>; ncells<span class="op">=</span><span class="fl">1</span>, showcell<span class="op">=</span><span class="cn">true</span>, showbonds<span class="op">=</span><span class="cn">true</span>, cmap<span class="op">=:</span>PuOr_5) <span class="op">=</span> <span class="fu">plotcrystal!</span>(ax, c,</span>
<span id="cb12-50"><a href="#cb12-50" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">0</span> <span class="fl">1</span> <span class="fl">1</span> <span class="fl">0</span> <span class="fl">0</span> <span class="fl">0</span> <span class="fl">0</span> <span class="fl">0</span> <span class="fl">0</span> <span class="fl">1</span> <span class="fl">1</span> <span class="fl">1</span> <span class="fl">1</span> <span class="fl">1</span> <span class="fl">1</span> <span class="fl">1</span> <span class="fl">0</span> <span class="fl">0</span> <span class="fl">1</span>;</span>
<span id="cb12-51"><a href="#cb12-51" aria-hidden="true" tabindex="-1"></a>     <span class="fl">0</span> <span class="fl">0</span> <span class="fl">1</span> <span class="fl">1</span> <span class="fl">0</span> <span class="fl">0</span> <span class="fl">1</span> <span class="fl">1</span> <span class="fl">0</span> <span class="fl">0</span> <span class="fl">0</span> <span class="fl">1</span> <span class="fl">1</span> <span class="fl">0</span> <span class="fl">0</span> <span class="fl">1</span> <span class="fl">1</span> <span class="fl">0</span> <span class="fl">0</span>;</span>
<span id="cb12-52"><a href="#cb12-52" aria-hidden="true" tabindex="-1"></a>     <span class="fl">0</span> <span class="fl">0</span> <span class="fl">0</span> <span class="fl">0</span> <span class="fl">0</span> <span class="fl">1</span> <span class="fl">1</span> <span class="fl">0</span> <span class="fl">0</span> <span class="fl">0</span> <span class="fl">1</span> <span class="fl">1</span> <span class="fl">0</span> <span class="fl">0</span> <span class="fl">1</span> <span class="fl">1</span> <span class="fl">1</span> <span class="fl">1</span> <span class="fl">1</span>]; ncells, showcell, showbonds, cmap<span class="op">=</span>cmap);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Oh boy…Ok, so what does it do? Plot crystals, obviously. It has the option to show a supercell consisting of multiple unit cells (the <code>ncells</code> argument), show the unit cell outline (<code>showcell</code>), and show bonds between nearest neighbors (<code>showbonds</code>). Let’s ignore the supercell for a moment, and see what it does in a single unit cell. The sites are easiest, where it just iterates over their positions and plots them as a scatter-plot (the color is determined by the site label automatically). The cell outline is very easy thanks to our use of reduced coordinates because, in those, it’s always a unit square/cube. The <code>vertpos</code> argument expects a matrix where the columns are the unit cell vertices (in reduced coordinates) and it plots a path between them (I use multiple dispatch here so that users don’t have to think about it). The bonds of nearest neighbors are found by replicating all atomic positions also in cells around the current unit cell, sorting them by length, and getting rid of all that have a length of 0 or larger than the smallest length. Extention to drawing a supercell is trivial because, in reduced coordinates, cells are integer multiples of length apart. For good measure, I also added the <code>cmap</code> argument that accepts any of the Makie-compatible <a href="https://makie.juliaplots.org/stable/documentation/colors/">color schemes</a> for all the people who might be colorblind, disagree with my taste, or both.</p>
<p>Let’s try it out. If you want to find lattice constants and unit cells of various materials, I recommend using the <a href="https://materialsproject.org">Materials Project</a>. It’s a database of calculated material structures (and a bunch of their electronic and mechanical properties) that gives the lattice parameters in the format our code expects. We can try graphene and hexagonal Boron Nitride (hBN), both with the same hexagonal structure. Hexagonal crystals have a triangular lattice with two atoms per unit cell, with the difference between graphene and hBN being that the latter has different atoms at the inequivalent positions:</p>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>graphene <span class="op">=</span> <span class="fu">Crystal</span>(</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">Lattice</span>(<span class="fl">2.468</span>Å, <span class="fl">2.468</span>Å, <span class="fl">120</span>),</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">UnitCell</span>(<span class="op">:</span>C, [<span class="fl">2</span><span class="op">/</span><span class="fl">3</span>, <span class="fl">1</span><span class="op">/</span><span class="fl">3</span>], [<span class="fl">1</span><span class="op">/</span><span class="fl">3</span>, <span class="fl">2</span><span class="op">/</span><span class="fl">3</span>])</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>hBN <span class="op">=</span> <span class="fu">Crystal</span>(</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">Lattice</span>(<span class="fl">2.512</span>Å, <span class="fl">2.512</span>Å, <span class="fl">120</span>),</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">UnitCell</span>([<span class="op">:</span>B, <span class="op">:</span>N], [<span class="fl">2</span><span class="op">/</span><span class="fl">3</span>, <span class="fl">1</span><span class="op">/</span><span class="fl">3</span>], [<span class="fl">1</span><span class="op">/</span><span class="fl">3</span>, <span class="fl">2</span><span class="op">/</span><span class="fl">3</span>])</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>It might be worth mentioning that the choice of primitive lattice vectors and site positions is not unique, and you might see different ways of creating the structure. (another option is having one atom at the origin and using 60º as the lattice angle).</p>
<p>With that done, we can access the primitive vector matrix that, in this case, does not form an orthogonal basis, as advertised earlier:</p>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>graphene.lattice.R</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="154">
<pre><code>2×2 Matrix{Float64}:
  4.03901  0.0
 -2.33192  4.66384</code></pre>
</div>
</div>
<div class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>graphene.lattice.R[<span class="op">:</span>,<span class="fl">1</span>] <span class="op">⋅</span> graphene.lattice.R[<span class="op">:</span>,<span class="fl">2</span>] <span class="op">!=</span> <span class="fl">0</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="155">
<pre><code>true</code></pre>
</div>
</div>
<p>After doing all the work, the visualization is easy:</p>
<div class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>fig2ds <span class="op">=</span> <span class="fu">Figure</span>()</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>axgs <span class="op">=</span> <span class="fu">Axis</span>(fig2ds; title <span class="op">=</span> <span class="st">"graphene"</span>, xlabel<span class="op">=</span><span class="st">"x/a₀"</span>, ylabel<span class="op">=</span><span class="st">"y/a₀"</span>, xgridvisible<span class="op">=</span><span class="cn">false</span>, ygridvisible<span class="op">=</span><span class="cn">false</span>, aspect <span class="op">=</span> <span class="fu">DataAspect</span>())</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>axhbns <span class="op">=</span> <span class="fu">Axis</span>(fig2ds; title <span class="op">=</span> <span class="st">"hBN"</span>, xlabel<span class="op">=</span><span class="st">"x/a₀"</span>, ylabel<span class="op">=</span><span class="st">"y/a₀"</span>, xgridvisible<span class="op">=</span><span class="cn">false</span>, ygridvisible<span class="op">=</span><span class="cn">false</span>, aspect <span class="op">=</span> <span class="fu">DataAspect</span>())</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="fu">plotcrystal!</span>(axgs, graphene, ncells<span class="op">=</span><span class="fl">3</span>)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="fu">plotcrystal!</span>(axhbns, hBN, ncells<span class="op">=</span><span class="fl">3</span>)</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>fig2ds[<span class="fl">1</span>,<span class="fl">1</span>] <span class="op">=</span> axgs</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>fig2ds[<span class="fl">1</span>,<span class="fl">2</span>] <span class="op">=</span> axhbns</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="fu">current_figure</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="156">
<p><img src="index_files/figure-html/cell-16-output-1.png" class="img-fluid"></p>
</div>
</div>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-5-contents" aria-controls="callout-5" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Note
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-5" class="callout-5-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>The way of plotting with <code>Makie</code> is almost identical to Python’s Matplotlib library if you’re using the object-oriented API (which you should be doing). I create a figure, with two axes, fill those two axes with the <code>plotcrystal!</code> routine, and position them into the figure. It’s that simple.</p>
<p>Sneaky TODO: At the time of writing this, I couldn’t figure out how to make legends work with 3D <code>meshscatter</code> plots. Hopefully, I’ll find a way to fix that.</p>
</div>
</div>
</div>
<p>As a quick tidbit, you can also nicely identify the two different crystal edges commonly mentioned in literature on nanotubes and other finite-sized systems. When you roll up graphene into a nanotube, you can do it along the unit cell edges, called zigzag edge, for obvious reasons. Or you can do it along a line perpendicular to those, called the armchair edge. If you stare at it for long enough, you can kinda-sorta see the armchair, but the names had to come from the same type of people who named stellar constellations (seriously, who looked at <a href="https://upload.wikimedia.org/wikipedia/commons/8/86/UrsaMajorCC.jpg">this</a> and thought “Totally a bear.”).</p>
<p>The routine works just as well for 3D crystals. Let’s take the diamond, which has two carbon atoms in a FCC lattice (sometimes called the diamond cubic lattice). The primitive unit cell of a FCC lattice is a rhombohedron, and the atoms are at positions (0,0,0) and (1/4,1/4,1/4), as I’m being told by the Materials Project’s <a href="https://materialsproject.org/materials/mp-66/">entry on diamond</a>:</p>
<div class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>diamond <span class="op">=</span> <span class="fu">Crystal</span>(</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">Lattice</span>(<span class="fl">2.527</span>Å, <span class="fl">2.527</span>Å, <span class="fl">2.527</span>Å, <span class="fl">60</span>, <span class="fl">60</span>, <span class="fl">60</span>),</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">UnitCell</span>(<span class="op">:</span>C, [<span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>], [<span class="fl">1</span><span class="op">/</span><span class="fl">4</span>, <span class="fl">1</span><span class="op">/</span><span class="fl">4</span>, <span class="fl">1</span><span class="op">/</span><span class="fl">4</span>])</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>fig3d <span class="op">=</span> <span class="fu">Figure</span>()</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>axds <span class="op">=</span> <span class="fu">Axis3</span>(fig3d, xlabel<span class="op">=</span><span class="st">"x/a₀"</span>, ylabel<span class="op">=</span><span class="st">"y/a₀"</span>, zlabel<span class="op">=</span><span class="st">"z/a₀"</span>, xgridvisible<span class="op">=</span><span class="cn">false</span>, ygridvisible<span class="op">=</span><span class="cn">false</span>, zgridvisible<span class="op">=</span><span class="cn">false</span>, aspect <span class="op">=</span> <span class="op">:</span>data)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>axds_single <span class="op">=</span> <span class="fu">Axis3</span>(fig3d, xlabel<span class="op">=</span><span class="st">"x/a₀"</span>, ylabel<span class="op">=</span><span class="st">"y/a₀"</span>, zlabel<span class="op">=</span><span class="st">"z/a₀"</span>, xgridvisible<span class="op">=</span><span class="cn">false</span>, ygridvisible<span class="op">=</span><span class="cn">false</span>, zgridvisible<span class="op">=</span><span class="cn">false</span>, aspect <span class="op">=</span> <span class="op">:</span>data)</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="fu">plotcrystal!</span>(axds, diamond; ncells<span class="op">=</span><span class="fl">2</span>, showcell<span class="op">=</span><span class="cn">false</span>, showbonds<span class="op">=</span><span class="cn">true</span>)</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="fu">plotcrystal!</span>(axds_single, diamond; ncells<span class="op">=</span><span class="fl">1</span>, showcell<span class="op">=</span><span class="cn">true</span>, showbonds<span class="op">=</span><span class="cn">true</span>)</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>fig3d[<span class="fl">1</span>,<span class="fl">1</span>] <span class="op">=</span> axds</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>fig3d[<span class="fl">1</span>,<span class="fl">2</span>] <span class="op">=</span> axds_single</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a><span class="fu">current_figure</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="158">
<p><img src="index_files/figure-html/cell-18-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>I plot a supercell that shows the diamond structure and a single unit cell with outlines, so you can see how the atoms and cells are stacked to create the diamond lattice. You can also rigidly offset the coordinates in the unit cell so that the two positions are (1/4,1/4,1/4) and (3/4,3/4,3/4), and the atoms sit neatly in the middle of the cell (it doesn’t affect physics).</p>
</section>
<section id="sec-cmpm3-BZ" class="level3">
<h3 class="anchored" data-anchor-id="sec-cmpm3-BZ">Who is Léon Brillouin?</h3>
<p>Having the structure of the crystals is nice and all, but that’s not the reason why we’re here. We want to be able to compute the <em>properties</em> of these crystals and, eventually, also optimize their shape. For that, we need to solve the Schroedinger equation with a Hamiltonian corresponding to the crystal. The Hamiltonian in general will consist of two parts: The Hamiltonian describing the electrons in the crystal and the Hamiltonian describing the atomic cores (and there’s also a part that describes how these two interact). Turns out that most properties of the crystal are due to the electrons. Also, experimentally, we’re most often also probing the electronic system, where interaction with e.g., light is mostly through scattering or absorption of photons by electrons (not to mention direct measurements of the electronic system, like with resistance measurements). For this reason, we’ll restrict our problem to just the dynamics of the electrons, with the atoms being there just as sources of time-independent electrostatic potential. This is called the Born-Oppenheimer approximation, and the physical motivation for this comes from the huge difference between electron and core masses (by a ratio of roughly 1/2000), which means that the electron dynamics are many orders of magnitude faster and the typical energies for electronic degrees of freedom are proportionally larger than the lattice degrees of freedom. The second approximation that we’ll make is that we assume non-interacting electrons. One would think that this is a rather strong assumption that does not correspond to reality but it turns out to work very well for microelectronics industry even these days. As we progress to more sophisticated methods, both of these approximations will be removed but, for now, our world is fully determined by solutions to this Schroedinger equation (in Rydberg units):</p>
<p><span class="math display">\[
\frac{1}{2}\nabla^2 \Psi(\vec{r}) + V(\vec{r}) \Psi(\vec{r}) = E \Psi(\vec{r}); \qquad V(\vec{r} + \vec{R}_n) = V(\vec{r}).
\]</span></p>
<p>Because an ideal crystal is infinitely periodic, doing calculations in a box like we did in the <a href="../../posts/cmpm2/">previous part</a> will not lead to a faithful representation of wavefunctions. A much better option is to represent states in their full wave-like glory.</p>
<p>For a moment, let’s pretend that the lattice is empty, i.e.&nbsp;<span class="math inline">\(V(\vec{r}) = 0\)</span>. In that case, we’re just solving the Hamiltonian of a free electron, with wave functions being just plane waves:</p>
<p><span class="math display">\[
\left| \theta_{\vec{k}} \right&gt; = \theta_{\vec{k}} (\vec{r}) = \frac{1}{\sqrt{2\pi}} e^{i \vec{k} \cdot \vec{r}}.
\]</span></p>
<p>When we do have a potential, it has to have the same periodicity as the lattice (by definition), so it can be expanded into only plane waves with reciprocal lattice wave vectors <span class="math inline">\(\vec{k} \in \left\{ \vec{G}_n \right\}\)</span>, as already explained a couple of paragraphs above:</p>
<p><span class="math display">\[
V(\vec{r}) = \sum_{\{\vec{G}_n\}}V(\vec{G}_n) e^{i \vec{G}_n \cdot \vec{r}},
\]</span> where <span class="math inline">\(V(\vec{G}_n)\)</span> are the Fourier components of the potential (you should slowly start seeing the importance of the reciprocal lattice).</p>
<p>Because of the of the sum in the potential, the action of the Hamiltonian on arbitrary plane wave state <span class="math inline">\(\left| \psi \right&gt; = H \left| \theta_{\vec{k}} \right&gt;\)</span> will generate a state that belongs to a relatively narrow subset of plane waves, namelly <span class="math inline">\(\left| \psi \right&gt; \in S_{\vec{k}} = \left\{ \left| \theta_{\vec{k} + \vec{G}_n} \right&gt; \right\}_n\)</span>. A set <span class="math inline">\(S_{\vec{k}}\)</span> is closed under application of <span class="math inline">\(H\)</span> (the action of <span class="math inline">\(H\)</span> on any element will generate another element of the same set), so there also has to exist a basis <span class="math inline">\(\left\{ \left| \phi_{\vec{k}} \right&gt; = \phi_{\vec{k}} (\vec{r})\right\}\)</span> in which the crystal Hamiltonian can be diagonalized (biggly important, I’ll talk about that in a second).</p>
<p>And this is where something magical happens: Two sets <span class="math inline">\(S_{\vec{k}}\)</span> and <span class="math inline">\(S_{\vec{k}^{\prime}}\)</span> are distinct if and only if <span class="math inline">\(\vec{k} - \vec{k}^{\prime} \not\in \left\{ \vec{G}_n \right\}\)</span>, which means that all physically distinct states exist only in a restricted sector of the reciprocal space, with <span class="math inline">\(\vec{k}\)</span> in the volume spanned by the primitive reciprocal vectors. This volume coincides with the primitive cell of the reciprocal lattice centered around <span class="math inline">\(\vec{k} = \vec{0}\)</span>. It’s called the <a href="https://en.wikipedia.org/wiki/Brillouin_zone">Brillouin zone</a> and every state of the crystal can be represented by eigenstates fully contained in it. Thanks to the breaking of the continuous translational symmetry of empty space, we can compress our momentum space down to a finite volume.</p>
<p>If you think about it for a bit, it follows what’s already happening in the real space. Because I can shift the origin point of real-space coordinates by arbitrary lattice vector and not change any property of the crystal, the only physically distinct positions also lie just in the primitive unit cell.</p>
</section>
<section id="its-waves-all-the-way-down" class="level3">
<h3 class="anchored" data-anchor-id="its-waves-all-the-way-down">It’s waves all the way down</h3>
<p>This should be all the groundwork needed to do actual physics, which starts with the computational basis. As I hinted in the previous section, there exists a space of characteristic functions in which the crystal Hamiltonian can be easily diagonalized. To find that basis, let’s write out the operators of the Hamiltonian explicitly as they act on a generic superposition of plane waves in the Brillouin zone:</p>
<p><span class="math display">\[
\sum_{\vec{k}} \left[ \varepsilon_{\vec{k}}^0 \, c_{\vec{k}} e^{i \vec{k} \cdot \vec{r}} + \sum_{\{ \vec{G_n} \}} V(\vec{G}_n) c_{\vec{k}} e^{i (\vec{k} + \vec{G}_n) \cdot \vec{r}} \right] = \varepsilon \sum_{\vec{k}} c_{\vec{k}} e^{i \vec{k} \cdot \vec{r}}
\]</span></p>
<p>Where <span class="math inline">\(\varepsilon_{\vec{k}}^0 = \frac{1}{2}\left| \vec{k} \right|^2\)</span> is the free electron energy. By comparing the coefficients of Fourier components (to find the <span class="math inline">\(k\)</span>-th component in the inner sum, you have to shift the dummy index <span class="math inline">\(\vec{k} \rightarrow \vec{k} - \vec{G}_n\)</span>), we arrive at an infinite algebraic system for the coefficients <span class="math inline">\(c_{\vec{k}}\)</span>:</p>
<p><span class="math display">\[
\left( \varepsilon_{\vec{k}}^0 - \varepsilon \right) c_{\vec{k}} + \sum_{\{ \vec{G}_n \}} V(\vec{G}_n) c_{\vec{k} - \vec{G}_n} = 0,
\]</span></p>
<p>which, if solved, will lead to eigenfunctions of the following form:</p>
<p><span class="math display">\[
\phi_{\vec{k}} (\vec{r}) = \sum_{\vec{G}_n} c_{\vec{k} - \vec{G}_n} e^{i (\vec{k} - \vec{G}_n) \cdot \vec{r}} = e^{i \vec{k} \cdot \vec{r}} \sum_{\vec{G}_n} c_{\vec{k} - \vec{G}_n} e^{-i \vec{G}_n \cdot \vec{k}} = e^{\vec{k} \cdot \vec{r}} u_{\vec{k}}(\vec{r}),
\]</span></p>
<p>where I absorbed the whole sum over reciprocal lattice vectors into a lattice-periodic function <span class="math inline">\(u_{\vec{k}} (\vec{r})\)</span> (and I also quietly hid the normalization into it). This is known as <a href="https://en.wikipedia.org/wiki/Bloch's_theorem">Bloch’s theorem</a>, and it’s the central building block of everything else in solid state and condensed matter physics. It’s so crucial because it proves that single-electron eigenstates of any crystal Hamiltonian are plane wave-like functions (there’s some modulation by the function <span class="math inline">\(u_{\vec{k}} (\vec{r})\)</span>) with quasi-momentum <span class="math inline">\(k\)</span>. Combined with the knowledge we gained in the previous section, this allows for a complete description of the full single-electronic spectrum within the Brillouin zone.</p>
<p>Technically, you can solve an arbitrary single-electron problem by solving the system of equations for <span class="math inline">\(c_{\vec{k}}\)</span>, but that turns out to be a not-so-easy task. As a matter of fact, it’s so not easy that people don’t usually even attempt a general solution…</p>
</section>
<section id="sec-cmpm3-kpath" class="level3">
<h3 class="anchored" data-anchor-id="sec-cmpm3-kpath">On the right (momentum) path</h3>
<p>Before we get to actual computation, it’s prudent to quickly think about how we typically graph quantities as functions of momentum <span class="math inline">\(\vec{k}\)</span> (or position, for that matter). It’s easy in one dimension, and you could also imagine plotting things as surfaces in two-dimensional systems. But plotting something as a dense function of 3D space becomes an issue. Your only option is to use lower-dimensional slices of the full space, and in a quantitative field like this one, you better make sure that those slices are as information-packed as possible.</p>
<p>Fortunately, because there are only a few Bravais lattices, there are equally few reciprocal lattices, and this structure can be exploited. Due to the high symmetry of the crystals and their duals, you can get a good feeling for the overall structure by working only along certain paths in the momentum space. These paths are usually called branches and they are straight lines that connect places in the Brillouin zone called <a href="https://en.wikipedia.org/wiki/Brillouin_zone#Critical_points">high symmetry (or critical) points</a>, called so because they are important for the symmetry operations of the crystal’s space group. The only thing I remember is that <span class="math inline">\(\Gamma\)</span> is the point <span class="math inline">\(\vec{k} = \vec{0}\)</span>. The rest I have to look up, so don’t feel bad for not remembering which labels belong to what positions.</p>
<p>Many of you probably encountered plots like this, even if you are not familiar with what you just read. It’s effectively the only way you’ll see people report <a href="https://i.stack.imgur.com/nCqb4.gif">band structure</a> calculations or measurements. Because calculating these is the most central part of computational solid state physics and chemistry, we should prepare a simple routine that will prepare the k-space trajectories for us:</p>
<div class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">kpath</span>(kpoints, dk)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    vertices <span class="op">=</span> <span class="fu">reverse</span>([point.second for point <span class="op">∈</span> kpoints])</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    labels <span class="op">=</span> [point.first for point <span class="op">∈</span> kpoints]</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    path <span class="op">=</span> [<span class="fu">last</span>(vertices)]</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    plength <span class="op">=</span> <span class="fu">zeros</span>(<span class="fu">typeof</span>(dk),<span class="fl">1</span>)</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    idxs <span class="op">=</span> [<span class="fl">1</span>]</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="fu">length</span>(vertices) <span class="op">&gt;=</span> <span class="fl">2</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>        <span class="fu">pop!</span>(path)</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>        v1 <span class="op">=</span> <span class="fu">pop!</span>(vertices)</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>        v2 <span class="op">=</span> <span class="fu">last</span>(vertices)</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>        dir <span class="op">=</span> v2 <span class="op">.-</span> v1</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>        dirm <span class="op">=</span> <span class="fu">norm</span>(dir)</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>        segment <span class="op">=</span> [v1 <span class="op">.+</span> dir <span class="op">.*</span> dd </span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>            for dd <span class="op">∈</span> <span class="fu">range</span>(start <span class="op">=</span> <span class="fl">0</span>, stop <span class="op">=</span> <span class="fl">1</span>, step <span class="op">=</span> <span class="fu">around</span>(dk<span class="op">/</span>dirm))]</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>        path <span class="op">=</span> <span class="fu">append!</span>(path,segment)</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>        idxs <span class="op">=</span> <span class="fu">push!</span>(idxs, <span class="fu">last</span>(idxs) <span class="op">+</span> <span class="fu">length</span>(segment) <span class="op">-</span> <span class="fl">1</span>)</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>    plength <span class="op">=</span> <span class="fu">append!</span>(plength,</span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Iterators</span>.<span class="fu">accumulate</span>(</span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>            <span class="op">+</span>,[<span class="fu">norm</span>(v2 <span class="op">.-</span> v1) for (v1,v2) <span class="op">∈</span> <span class="fu">zip</span>(path[<span class="fl">1</span><span class="op">:</span><span class="kw">end</span><span class="op">-</span><span class="fl">1</span>], path[<span class="fl">2</span><span class="op">:</span><span class="kw">end</span>])]</span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>            ))</span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>    points <span class="op">=</span> [lab <span class="op">=&gt;</span> plength[i] for (lab,i) <span class="op">∈</span> <span class="fu">zip</span>(labels, idxs)]</span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>    (path<span class="op">=</span>path, plength<span class="op">=</span>plength, ppoints<span class="op">=</span>points)</span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Nothing particularly exciting or complicated. The function just takes a vector of pairs <code>point_name =&gt; [coordinate]</code> in order of how they are supposed to be traversed (I wanted to go with a dictionary, but I need some of the points to repeat), and the k-spacing <em>along the path</em>. It returns a named 3-tuple, where <code>path</code> is a vector of reduced k-coordinates along the path, <code>plength</code> is the distance along the path, and <code>ppoints</code> a vector of pairs <code>point_name =&gt; distance_at_point</code>. We don’t really need anything except <code>path</code>, but the other two are very useful for plotting.</p>
<p>Now back to physics.</p>
</section>
<section id="sec-cmpm3-fe" class="level3">
<h3 class="anchored" data-anchor-id="sec-cmpm3-fe">Free as the wind</h3>
<p>While Bloch’s theorem is constructive in terms of defining what the physical states are, it has proven to be cumbersome in practical reality. Finding the expansion coefficients with some realistic Hamiltonian requires solving humongous algebraic systems and often makes it hard to incorporate (or gain) some physical intuition or phenomenology. Because of that, we developed a bunch of models and methods which are limiting cases.</p>
<p>The by far simplest method to give you a very, <em>very</em> rough idea of a band structure, is the use of what’s known as the empty lattice approximation. As the name suggests, you take an empty space and, in your mind’s eye, imagine that it’s periodic, eliminating any complications that might or might not arise from your feeble attempts at using Bloch’s theorem. All this does is, rather depressingly, take the free electron and imprison it in the Brillouin zone. Or, in less prosaic terms, you take the free-space parabolic dispersion, replicate it offset by the reciprocal vectors <span class="math inline">\(\{ \vec{G}_n \}\)</span> and cut out only the Brillouin zone. The Hamiltonian in that case is very easy:</p>
<p><span class="math display">\[
H(\vec{k}) = \sum_{\left\{ \vec{G}_n \right\}}\frac{1}{2} \left( \vec{k}  + \vec{G}_n\right)^2,
\]</span></p>
<p>Which is just a diagonal matrix. To put this in code, we only have to decide how many bands we want to recover (i.e., how many <span class="math inline">\(\vec{G}_n\)</span> we use), which will determine the size of the matrix.</p>
<div class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">elH</span>(k, n, crystal<span class="op">::</span><span class="dt">Crystal</span>)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    G <span class="op">=</span> crystal.lattice.G</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">map</span>(<span class="fu">sort</span>(<span class="bu">Iterators</span>.<span class="fu">product</span>(<span class="fu">fill</span>(<span class="op">-</span>n<span class="op">:</span>n,<span class="fu">length</span>(k))<span class="op">...</span>) <span class="op">|&gt;</span> collect <span class="op">|&gt;</span> vec, by<span class="op">=</span>norm)) <span class="cf">do</span> Gn</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>        q <span class="op">=</span> G<span class="op">'</span> <span class="op">*</span> <span class="fu">collect</span>(k <span class="op">.-</span> Gn)</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>        <span class="fl">1</span><span class="op">/</span><span class="fl">2</span><span class="fu">*norm</span>(q)<span class="op">^</span><span class="fl">2</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><em>It’s not </em>really* a Hamiltonian because I’m not returning a matrix. This is because it’s already diagonal, so I just return the vector of eigenvalues by using linear combinations of all <span class="math inline">\(\vec{G}\)</span>s up to <code>n</code>-times the primitive reciprocal vectors.*</p>
<p>To demonstrate, it’s best to start with a 1D case:</p>
<div class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>crystal1D <span class="op">=</span> <span class="fu">Crystal</span>(</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">Lattice</span>(<span class="fl">1.0</span>),</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">UnitCell</span>(<span class="fl">0.0</span>)</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>kpath1D <span class="op">=</span> <span class="op">-</span><span class="fl">1.5</span><span class="op">:</span><span class="fl">0.01</span><span class="op">:</span><span class="fl">1.5</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="fu">elH1D</span>(k) <span class="op">=</span> <span class="fu">elH</span>(k, <span class="fl">1</span>, crystal1D)</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>es1D <span class="op">=</span> <span class="fu">elH1D</span>.(kpath1D);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>fig_1D <span class="op">=</span> <span class="fu">Figure</span>()</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>ax_1D1 <span class="op">=</span> <span class="fu">Axis</span>(fig_1D, title<span class="op">=</span><span class="st">"Extended zone scheme"</span>)</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>ax_1D2 <span class="op">=</span> <span class="fu">Axis</span>(fig_1D, title<span class="op">=</span><span class="st">"First Brillouin zone"</span>)</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n <span class="op">∈</span> <span class="fl">1</span><span class="op">:</span><span class="fu">length</span>(es1D[<span class="fl">1</span>])</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">lines!</span>(ax_1D1, kpath1D, [<span class="cn">e</span>[n] for <span class="cn">e</span> <span class="op">∈</span> es1D])</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">lines!</span>(ax_1D2, kpath1D, [<span class="cn">e</span>[n] for <span class="cn">e</span> <span class="op">∈</span> es1D])</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a><span class="fu">hideydecorations!</span>(ax_1D1)</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a><span class="fu">hideydecorations!</span>(ax_1D2)</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>ax_1D1.xticks <span class="op">=</span> ([<span class="op">-</span><span class="fl">1</span><span class="op">/</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>], [<span class="st">"-π/a"</span>,<span class="st">"π/a"</span>])</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>ax_1D2.xticks <span class="op">=</span> ([<span class="op">-</span><span class="fl">1</span><span class="op">/</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>], [<span class="st">"-π/a"</span>,<span class="st">"π/a"</span>])</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a><span class="fu">ylims!</span>(ax_1D1, (<span class="fl">0</span>,<span class="fl">30</span>))</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a><span class="fu">ylims!</span>(ax_1D2, (<span class="fl">0</span>,<span class="fl">30</span>))</span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a><span class="fu">xlims!</span>(ax_1D2, (<span class="op">-</span><span class="fl">1</span><span class="op">/</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>))</span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>fig_1D[<span class="fl">1</span>,<span class="fl">2</span>] <span class="op">=</span> ax_1D1</span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a>fig_1D[<span class="fl">1</span>,<span class="fl">1</span>] <span class="op">=</span> ax_1D2</span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a><span class="fu">current_figure</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="162">
<p><img src="index_files/figure-html/cell-22-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>In one dimension, life is simple. The reciprocal space is just a line, so we don’t have to deal with k-branches and <code>n</code>=1 (<span class="math inline">\(\left\{ \vec{G}_n \right\} = \left\{ -1,0,1 \right\}\)</span>) is sufficient to recover three “bands”. On the left you see the conventional way to graph band diagrams (Brillouin zone for a 1D crystal is the line segment <span class="math inline">\(\left[-\frac{\pi}{a},\frac{\pi}{a} \right]\)</span>, or <span class="math inline">\(\left[-\frac{1}{2},\frac{1}{2} \right]\)</span> in reduced coordinates). On the right, I plotted the band diagram in what’s known as the extended zone, where I included neighboring reciprocal cells. This way, you can see how the shifted parabolas lead to the bands in the first zone.</p>
<p>You won’t find too many one-dimensional crystals in the wild. And if you do, they frequently turn out to be insulators (for reasons that we’ll get into when I’ll do the part on electron-phonon interaction), so the empty lattice approximation will not do us too much good from the practical perspective. We should move up to three dimensions, specifically to a crystal of plain old aluminum. I choose aluminum because it’s a simple metal with good conductivity and atomic orbital structure that isn’t prone to any relativistic nonsense. In materials like that, the band structure can be reasonably well described by effectively a bucket of electrons in empty space. By looking it up in our trusty Materials Project registry, we find out that aluminum has a simple <a href="https://materialsproject.org/materials/mp-134/">FCC structure</a> with a lattice constant of 2.856 Å and a single atom in the unit cell:</p>
<div class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>Al <span class="op">=</span> <span class="fu">Crystal</span>(</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">Lattice</span>(<span class="fl">2.856</span>Å,<span class="fl">2.856</span>Å,<span class="fl">2.856</span>Å,<span class="fl">60</span>,<span class="fl">60</span>,<span class="fl">60</span>),</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">UnitCell</span>(<span class="op">:</span>Al, [<span class="fl">0.0</span>,<span class="fl">0.0</span>,<span class="fl">0.0</span>])</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Because we won’t be able to fully plot the dispersion in 3D space, we have to start using our <code>kpath</code> routine to construct a path between high symmetry points. I use the trajectory that Materials Project uses so that we can compare our calculations to their DFT results (which should be good to chemical precision for something simple like aluminum):</p>
<div class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>Alks <span class="op">=</span> <span class="fu">kpath</span>([</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span>Γ <span class="op">=&gt;</span> [<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>],</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span>X <span class="op">=&gt;</span> [<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>,<span class="fl">0</span>,<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>],</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span>W <span class="op">=&gt;</span> [<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">/</span><span class="fl">4</span>,<span class="fl">3</span><span class="op">/</span><span class="fl">4</span>],</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span>K <span class="op">=&gt;</span> [<span class="fl">3</span><span class="op">/</span><span class="fl">8</span>,<span class="fl">3</span><span class="op">/</span><span class="fl">8</span>,<span class="fl">3</span><span class="op">/</span><span class="fl">4</span>],</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span>Γ <span class="op">=&gt;</span> [<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>],</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span>L <span class="op">=&gt;</span> [<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>],</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span>U <span class="op">=&gt;</span> [<span class="fl">5</span><span class="op">/</span><span class="fl">8</span>,<span class="fl">1</span><span class="op">/</span><span class="fl">4</span>,<span class="fl">5</span><span class="op">/</span><span class="fl">8</span>],</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span>W <span class="op">=&gt;</span> [<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">/</span><span class="fl">4</span>,<span class="fl">3</span><span class="op">/</span><span class="fl">4</span>],</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span>L <span class="op">=&gt;</span> [<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>],</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span>K <span class="op">=&gt;</span> [<span class="fl">3</span><span class="op">/</span><span class="fl">8</span>,<span class="fl">3</span><span class="op">/</span><span class="fl">8</span>,<span class="fl">3</span><span class="op">/</span><span class="fl">4</span>]</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>        ], <span class="fl">0.01</span>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The rest is the same as in the 1D calculation.</p>
<div class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="fu">alH_el</span>(k) <span class="op">=</span> <span class="fu">elH</span>(k, <span class="fl">2</span>, Al)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>es_al_el <span class="op">=</span> <span class="fu">alH_el</span>.(Alks.path);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>fig_Al_el <span class="op">=</span> <span class="fu">Figure</span>()</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>ax_Al_el <span class="op">=</span> <span class="fu">Axis</span>(fig_Al_el)</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>ax_Al_el.xticks <span class="op">=</span> ([p.second for p <span class="op">∈</span> Alks.ppoints], </span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>                 [<span class="fu">string</span>(p.first) for p <span class="op">∈</span> Alks.ppoints])</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="fu">ylims!</span>(ax_Al_el, (<span class="fl">0</span>,<span class="fl">1</span>))</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span class="fu">xlims!</span>(ax_Al_el, (<span class="fl">0</span>, Alks.plength[<span class="kw">end</span>]))</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a><span class="fu">hideydecorations!</span>(ax_Al_el)</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n <span class="op">∈</span> <span class="fl">1</span><span class="op">:</span><span class="fu">length</span>(es_al_el[<span class="fl">1</span>])</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">lines!</span>(Alks.plength, [<span class="cn">e</span>[n] for <span class="cn">e</span> <span class="op">∈</span> es_al_el])</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>fig_Al_el[<span class="fl">1</span>,<span class="fl">1</span>] <span class="op">=</span> ax_Al_el</span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a><span class="fu">current_figure</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="166">
<p><img src="index_files/figure-html/cell-26-output-1.png" class="img-fluid"></p>
</div>
</div>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-6-contents" aria-controls="callout-6" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
On extra output of <code>kpath</code>
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-6" class="callout-6-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Now you see why I added the extra information to the output of <code>kpath</code>, where the x-axis is now the length along the k-path (<code>plength</code>) and the labels sit at the correct places (to do that, you just overwrite the member <code>xticks</code> which is a tuple of two vectors, one with positions on the x-axis and one with strings for the names).</p>
</div>
</div>
</div>
<p>The rough features of the band structure are there when compared to the <a href="https://materialsproject.org/materials/mp-134?chemsys=Al#electronic_structure">real stuff</a>, but the details are obviously all wrong. The energy scale is, of course, way off and I don’t even bother showing it. What’s even worse, this calculation would give the same bands for aluminum and diamond (remember, the only thing that plays a role here is the Bravais lattice), which is recognizably not true - one is reflective while the other is transparent, so there has to be a difference in how the electrons interact with light, and that should be reflected in the band structure. To fix all that, we have to stop pretending that a crystal is just an empty space and start including the effects of the atomic potentials.</p>
</section>
<section id="sec-cmpm3-nfe" class="level3">
<h3 class="anchored" data-anchor-id="sec-cmpm3-nfe">Not so free after all</h3>
<p>We know that the Hamiltonian eigenstates are somewhat plane-wave-like in their nature, so let’s not drop the idea of free-electron dispersion entirely. Instead, let’s pretend that the empty lattice Hamiltonian is <em>the</em> Hamiltonian and that the electrostatic potential of the atomic cores is very weak.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> If that’s true, we can apply <a href="https://en.wikipedia.org/wiki/Perturbation_theory_(quantum_mechanics)">perturbation theory</a> and see what corrections the potential makes to the eigenenergies:</p>
<p><span class="math display">\[
\varepsilon_{\vec{k}} = \varepsilon ^0 _{\vec{k}} + \left&lt; \vec{k} \right| \hat{V} \left| \vec{k} \right&gt; + \sum_{\vec{k} \not= \vec{k}^{\prime}} \frac{\left| \left&lt; \vec{k}^{\prime} \right| \hat{V} \left| \vec{k} \right&gt; \right|^2}{\varepsilon ^0 _{\vec{k}} - \varepsilon ^0 _{\vec{k}^{\prime}}}
\]</span></p>
<p>Because the states <span class="math inline">\(\left| \vec{k} \right&gt;\)</span> are plane waves, the elements <span class="math inline">\(\left&lt; \vec{k}^{\prime} \right| \hat{V} \left| \vec{k} \right&gt; = \int dx e^{-i \vec{k}^{\prime} \cdot \vec{x}} V(\vec{x}) e^{i \vec{k} \cdot \vec{x}}\)</span> are just Fourier components <span class="math inline">\(V(\vec{k}^{\prime} - \vec{k}) = V_{\vec{k}^{\prime} - \vec{k}}\)</span>, which are non-zero only when <span class="math inline">\(\vec{k}^{\prime} - \vec{k} \in \left\{ \vec{G}_n \right\}\)</span>, so I can rewrite the above more compactly:</p>
<p><span class="math display">\[
\varepsilon_{\vec{k}} = \varepsilon ^0 _{\vec{k}} + V_0 + \sum_{\left\{ \vec{G}_n \right\}} \frac{\left| V_{\vec{G}_n} \right|^2}{\varepsilon ^0 _{\vec{k}} - \varepsilon ^0 _{\vec{k} + \vec{G}_n}}.
\]</span></p>
<p>The first thing to notice is that the first-order perturbation leads to just a correction by a constant term <span class="math inline">\(V_0\)</span> that we can, for now, set to zero (it doesn’t change the bands). Relevant corrections happen in the second order, where we can see that they are inversely proportional to the energy difference between the bands at a given k-value. If you look at the empty lattice plots, you can see that the energy difference is usually small. The exceptions are Brillouin zone edges, where the plane wave states are degenerate with their counterparts from higher bands. As the wiki article tells us, the path forward in the case of degenerate perturbation theory is to find the new eigenstates and eigenenergies, which amounts to finding eigenvalues of the Hamiltonian with matrix elements:</p>
<p><span class="math display">\[
\left&lt; \vec{G}_m \right| H(\vec{k}) \left| \vec{G}_n \right&gt; = \varepsilon^0 _{\vec{k} + \vec{G}_n} \delta_{nm} + V_{\vec{G}_m - \vec{G}_n}.
\]</span></p>
<p>This Hamiltonian corresponds to what is known as the Nearly free electron model and it’s diagonal in a basis that’s formed by a set of linear combinations of plane waves, the Bloch functions. In principle, the potential matrix elements should be Fourier components of the real potential that an electron feels around the atoms of the unit cell (the Z/r electrostatic potential). Expansion of potential like that tends to be computationally inefficient if we’re interested only in properties of select bands or k-points. Instead, one can come up with a similar potential that is better behaved and can be represented only by a small number of Fourier components. This is called the pseudopotential method and, depending on how the potential matrix elements are determined, can be either empirical (when a few free parameters are fitted to experimental probes of the band structure like <a href="https://en.wikipedia.org/wiki/Photoemission_spectroscopy">photoemisson</a> or <a href="https://en.wikipedia.org/wiki/De_Haas–Van_Alphen_effect">De Haas-Van Alphen effect</a>) or ab-initio (if you, e.g., extrapolate from first-principles calculations of a single atom).</p>
<p>It works nicely for some materials, usually simple conductors<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>, but the method is not universal in practice. It fails spectacularly in insulators, where the localized core states are important: A typical core s-state of an atom with an atomic number <span class="math inline">\(Z\)</span> has a radius of approximately <span class="math inline">\(a_0 / Z\)</span>, and to represent it nicely in plane waves, we have to use k-values with magnitude up to <span class="math inline">\(k_{max} = \frac{2\pi Z}{a_0}\)</span>. The number of reciprocal lattice vectors <span class="math inline">\(n\)</span> inside this volume can be estimated by <span class="math inline">\(\frac{4\pi}{3}k_{max}^3 = \frac{(2\pi)^3n}{V}\)</span>, from which we see that the number is proportional to the third power of the product of atomic number and reduced lattice constant <span class="math inline">\(n \approx Z^3 (a/a_0)^3\)</span>. So in most materials, we would end up diagonalizing a roughly <span class="math inline">\(10^6 \times 10^6\)</span> element matrix (not to mention that the electrostatic potential near the atomic core is anything but weak, which brings into question whether the perturbation approach is even valid).</p>
<p>That, however, shouldn’t stop us from implementing the method and using it. We just need to be aware of the limitations. And the implementation is really simple:</p>
<div class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">nfH</span>(k, n<span class="op">::</span><span class="dt">Integer</span>, V<span class="op">::</span><span class="dt">Function</span>, crystal<span class="op">::</span><span class="dt">Crystal</span>)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    G <span class="op">=</span> crystal.lattice.G</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    <span class="cn">e</span> <span class="op">=</span> <span class="fu">sort</span>(<span class="bu">Iterators</span>.<span class="fu">product</span>(<span class="fu">fill</span>(<span class="op">-</span>n<span class="op">:</span>n,<span class="fu">length</span>(k))<span class="op">...</span>) <span class="op">|&gt;</span> collect <span class="op">|&gt;</span> vec, by<span class="op">=</span>norm) <span class="op">|&gt;</span> collect</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> G<span class="op">'</span> <span class="op">*</span> k</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    Gs <span class="op">=</span> (G<span class="op">'</span> <span class="op">*</span> <span class="fu">collect</span>(g) <span class="cf">for</span> g <span class="op">∈</span> <span class="cn">e</span>)</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    H <span class="op">=</span> [<span class="fu">V</span>(j <span class="op">-</span> i) for i <span class="op">∈</span> Gs, j <span class="op">∈</span> Gs]</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>    H <span class="op">.+=</span> <span class="fu">diagm</span>((<span class="fl">1</span><span class="op">/</span><span class="fl">2</span><span class="fu">*norm</span>(k <span class="op">.+</span> g)<span class="op">^</span><span class="fl">2</span> <span class="cf">for</span> g <span class="op">∈</span> Gs) <span class="op">|&gt;</span> collect)</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">nfH</span>(k, <span class="cn">e</span><span class="op">::</span><span class="dt">Vector</span>, V<span class="op">::</span><span class="dt">Matrix</span>, crystal<span class="op">::</span><span class="dt">Crystal</span>)</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>    G <span class="op">=</span> crystal.lattice.G</span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> G<span class="op">'</span> <span class="op">*</span> k</span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>    Gs <span class="op">=</span> (G<span class="op">'</span> <span class="op">*</span> g <span class="cf">for</span> g <span class="op">∈</span> <span class="cn">e</span>)</span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>    V <span class="op">.+</span> <span class="fu">diagm</span>((<span class="fl">1</span><span class="op">/</span><span class="fl">2</span><span class="fu">*norm</span>(k <span class="op">.+</span> g)<span class="op">^</span><span class="fl">2</span> <span class="cf">for</span> g <span class="op">∈</span> Gs) <span class="op">|&gt;</span> collect)</span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>I added two methods: One mirrors the empty lattice but includes the function <span class="math inline">\(V(\vec{k})\)</span>. Another that requires you to explicitly provide a set of <span class="math inline">\(\vec{G}_n\)</span>s of interest and associated matrix representation of <span class="math inline">\(V\)</span>.</p>
<p>We should start with the 1D model:</p>
<div class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>V1d <span class="op">=</span> [<span class="fl">0</span> <span class="fl">1</span> <span class="fl">1</span>; </span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>       <span class="fl">1</span> <span class="fl">0</span> <span class="fl">1</span>;</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>       <span class="fl">1</span> <span class="fl">1</span> <span class="fl">0</span>]</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="fu">nfH1D</span>(k) <span class="op">=</span> <span class="fu">nfH</span>(k, [<span class="op">-</span><span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">1</span>], V1d, crystal1D)</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>nf1Des <span class="op">=</span> <span class="fu">nfH1D</span>.(kpath1D) <span class="op">.|&gt;</span> eigvals;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>fig_1D_nf <span class="op">=</span> <span class="fu">Figure</span>()</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>ax_1D_nf <span class="op">=</span> <span class="fu">Axis</span>(fig_1D_nf)</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n <span class="op">∈</span> <span class="fl">1</span><span class="op">:</span><span class="fu">length</span>(es1D[<span class="fl">1</span>])</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">lines!</span>(ax_1D_nf, kpath1D, [<span class="cn">e</span>[n] for <span class="cn">e</span> <span class="op">∈</span> es1D], color<span class="op">=:</span>gray)</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n <span class="op">∈</span> <span class="fl">1</span><span class="op">:</span><span class="fu">length</span>(nf1Des[<span class="fl">1</span>])</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">lines!</span>(ax_1D_nf, kpath1D, [<span class="cn">e</span>[n] for <span class="cn">e</span> <span class="op">∈</span> nf1Des])</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a><span class="fu">hideydecorations!</span>(ax_1D_nf)</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>ax_1D_nf.xticks <span class="op">=</span> ([<span class="op">-</span><span class="fl">1</span><span class="op">/</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>], [<span class="st">"-π/a"</span>,<span class="st">"π/a"</span>])</span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a><span class="fu">ylims!</span>(ax_1D_nf, (<span class="fl">0</span>,<span class="fl">30</span>))</span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a><span class="fu">xlims!</span>(ax_1D_nf, (<span class="op">-</span><span class="fl">1</span><span class="op">/</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>))</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>fig_1D_nf[<span class="fl">1</span>,<span class="fl">1</span>] <span class="op">=</span> ax_1D_nf</span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a><span class="fu">current_figure</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="169">
<p><img src="index_files/figure-html/cell-29-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>It’s finally becoming clear why it’s called a <em>band</em> structure. The presence of nonzero matrix elements in <span class="math inline">\(V\)</span> modifies the dispersion of a free electron (grey curve) and lifts the degeneracy at band crossings, just as you would expect from the perturbation formula above. This creates energy intervals of allowable energy bands (you can see three of them here) separated by regions on the energy axis where there are no eigenvalues (band gaps).</p>
<p>Let’s now get back to aluminum. I could go the route of constructing the matrix with coefficients as necessary to fit results, but there’s a more fun approach. Because it’s a simple metal, there’s a good chance that the conduction electrons can be modeled as an electron gas, which will screen the atomic core potential through Thomas-Fermi screening that we’ve encountered before. The screened potential has a form <span class="math inline">\(\frac{Q}{r}e^{-\vec{q}\cdot\vec{r}}\)</span>, which has Fourier components proportional to <span class="math inline">\(\frac{4\pi Q}{k^2 + q^2}\)</span>:</p>
<div class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="fu">V</span>(g, Q, q) <span class="op">=</span> <span class="fu">ifelse</span>(<span class="fu">norm</span>(g) <span class="op">≈</span> <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">4</span>π <span class="op">*</span> Q<span class="op">/</span>(<span class="fu">norm</span>(g)<span class="op">^</span><span class="fl">2</span> <span class="op">.+</span> q<span class="op">^</span><span class="fl">2</span>));</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Where I set the <span class="math inline">\(V_0\)</span> term to zero. We can now plug in the effective nuclear charge of aluminum (<span class="math inline">\(Q = 3\)</span>) and make an educated guess on what’s the screening length <span class="math inline">\(1/q\)</span>. I could go and look up the electronic number density to calculate the proper screening length, but we’re just looking for a rough estimation (I’m neglecting a lot of things already), so let’s say that it get’s screened roughly on the order of lattice constant (<span class="math inline">\(\left| q \right| = 10\)</span>, so that the numbers fit):</p>
<div class="cell" data-execution_count="30">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="fu">AlV</span>(k) <span class="op">=</span> <span class="fu">V</span>(k, <span class="fl">3</span>, <span class="fl">10</span>)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="fu">AlH</span>(k) <span class="op">=</span> <span class="fu">nfH</span>(k, <span class="fl">2</span>, AlV, Al);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>Ales <span class="op">=</span> <span class="fu">AlH</span>.(Alks.path) <span class="op">.|&gt;</span> eigvals;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>fig_Al <span class="op">=</span> <span class="fu">Figure</span>()</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>ax_Al <span class="op">=</span> <span class="fu">Axis</span>(fig_Al, title<span class="op">=</span><span class="st">"Aluminum"</span>)</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>ax_Al.xticks <span class="op">=</span> ([p.second for p <span class="op">∈</span> Alks.ppoints], </span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>                [<span class="fu">string</span>(p.first) for p <span class="op">∈</span> Alks.ppoints])</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>ax_Al.yticks <span class="op">=</span> <span class="fl">0</span><span class="op">:</span><span class="fl">10</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>ax_Al.ylabel <span class="op">=</span> <span class="st">"E [Ha]"</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a><span class="fu">ylims!</span>(ax_Al, (<span class="op">-</span><span class="fl">0.2</span>,<span class="fl">0.4</span>))</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a><span class="fu">xlims!</span>(ax_Al, (<span class="fl">0</span>, Alks.plength[<span class="kw">end</span>]))</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a><span class="fu">hideydecorations!</span>(ax_Al, ticks<span class="op">=</span><span class="cn">false</span>, ticklabels<span class="op">=</span><span class="cn">false</span>, label<span class="op">=</span><span class="cn">false</span>)</span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n <span class="op">∈</span> <span class="fl">1</span><span class="op">:</span><span class="fu">length</span>(Ales[<span class="fl">1</span>])</span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>    <span class="fu">lines!</span>(Alks.plength, [<span class="cn">e</span>[n] for <span class="cn">e</span> <span class="op">∈</span> Ales])</span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>fig_Al[<span class="fl">1</span>,<span class="fl">1</span>] <span class="op">=</span> ax_Al</span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a><span class="fu">current_figure</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="173">
<p><img src="index_files/figure-html/cell-33-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Not bad, all things considered. I wouldn’t use it to determine chemistry or precise physical properties,but for a simple model with just one free parameter, it does really well (it’s almost as good as state-of-the-art calculations in the 1950s).</p>
</section>
<section id="sec-cmpm3-tb" class="level3">
<h3 class="anchored" data-anchor-id="sec-cmpm3-tb">Tightly bound</h3>
<p>Assuming that the atomic potentials are weak to the point of being almost non-existent is nice, but it’s rather restrictive on the type of materials we can handle. To cover the exact opposite case, let’s go to the other end of the Bloch’s theorem spectrum (pun intended), where the atomic potentials are very strong and just barely let the electrons escape.</p>
<p>To start, we’ll ignore the whole business of crystals and Dr.&nbsp;Bloch, and focus on a toy model for formation of covalent bonds: an ionized hydrogen molecule <span class="math inline">\(H_2 ^+\)</span>. It’s a very simple model, with a single electron flying around two protons at sites <span class="math inline">\(r_1\)</span> and <span class="math inline">\(r_2\)</span>, with the Hamiltonian:</p>
<p><span class="math display">\[
\hat{H} = \frac{1}{2}\nabla^2 - \frac{1}{r_1} - \frac{1}{r_2}.
\]</span></p>
<p>This is a problem that we already know how to solve in a finite box using the finite-resolution position/momentum eigenstates. But because we’re dealing with molecules, there are much more efficient methods, specifically the <a href="https://en.wikipedia.org/wiki/Linear_combination_of_atomic_orbitals">Linear combination of atomic orbitals (LCAO)</a> method. The idea is mostly the same, but instead of not-entirely-Dirac-delta or sine functions, it uses atomic orbitals as the basis. The low-lying electron states will be localized mostly around the individual protons (to minimize the potential energy), so it is reasonable to assume that the true electron state will be approximated to high precision by a linear combination of few atomic hydrogen wavefunctions (which is where the name of the method comes from). In the simplest case, we need to take just the <span class="math inline">\(1s\)</span> state around each of the protons:</p>
<p><span class="math display">\[
\psi(\vec{r}) = c_1 \varphi(\vec{r} - \vec{r}_1) + c_2 \varphi(\vec{r} - \vec{r}_2),
\]</span></p>
<p>where <span class="math inline">\(\varphi(\vec{r})\)</span> is an orbital (<span class="math inline">\(\frac{1}{\sqrt{\pi}}e^{-\left| \vec{r} \right|}\)</span> in the hydrogen <span class="math inline">\(1s\)</span> state in atomic units). It’s worth mentioning that <span class="math inline">\(\varphi\)</span> need not be a hydrogen-like eigenstate, this would work with any reasonable and localized state centered around the proton sites, albeit with worse precision. The constants <span class="math inline">\(c_1\)</span> and <span class="math inline">\(c_2\)</span> can theoretically be arbitrary complex numbers such that <span class="math inline">\(c_1^2 + c_2^2 = 1\)</span>, which is a bit of a pain. Fortunately, it can be shown that, in case of a molecule with mirror symmetry, we need just the symmetric and anti-symmetric combinations <span class="math inline">\(\psi(\vec{r})_{\pm} = \varphi(\vec{r} - \vec{r}_1) \pm \varphi(\vec{r} - \vec{r}_2)\)</span>. To calculate expectation values, we need to know the norm of the combinatorial states:</p>
<p><span class="math display">\[
\left&lt; \psi_{\pm} | \psi_{\pm} \right&gt; = \int d^3 \vec{r} \left| \psi(\vec{r})_{\pm} \right|^2 = \int d^3\vec{r} \left[ \varphi^2(\vec{r}_1) + \varphi^2(\vec{r}_2) \pm 2\varphi(\vec{r}_1)\varphi(\vec{r}_2)  \right] = 2 (1 \pm S),
\]</span></p>
<p>where <span class="math inline">\(S = \int d^3\vec{r}\varphi(\vec{r}_1)\varphi(\vec{r}_2)\)</span> is what’s known as an overlap integral. From there, can express the energy expectation values of the two variational states as:</p>
<p><span class="math display">\[
E_{\pm} = \frac{\left&lt; \psi_{\pm} \right| H \left| \psi_{\pm} \right&gt;}{\left&lt; \psi_{\pm} | \psi_{\pm} \right&gt;} = \frac{\mu \mp \gamma}{1 \pm S},
\]</span></p>
<p>where <span class="math inline">\(\mu = \left&lt; \varphi(\vec{r}_1) \right| H \left| \varphi(\vec{r}_1) \right&gt;\)</span> is called on-site energy (the energy cost/saving of dropping a single electron into the molecule) and <span class="math inline">\(\gamma = -\left&lt; \varphi(\vec{r}_1) \right| H \left| \varphi(\vec{r}_2) \right&gt;\)</span> is what’s known as tunneling amplitude or hopping term (modulo some units, it determines the tunneling rate between the two atomic states). As a nice exercise, you should calculate the three integrals and energy as a function of proton distance, where you would find that the minimum occurs at finite values for the symmetric state. The value you should get something around 1.32 Å, which is within 30% or so of the real number (meh?). The real value of this is in showing that the two hydrogen atoms form a covalent chemical bond, even though the two potential wells are rather deep and the original atomic states rather localized and don’t overlap too much.</p>
<p>Of course, nothing says that the same approach cannot be used for bigger systems, like atoms arranged in crystals. So let’s imagine the same situation as above, but this time, have many atoms sitting at lattice sites <span class="math inline">\(\vec{R}_n\)</span>, contributing a set of orbitals <span class="math inline">\(\left\{ \varphi_a(\vec{r} - \vec{R}_n) \right\}\)</span>. Using the same arguments as with the hydrogen molecule, we can construct a basis that’s a linear combination of these orbitals. Given that the set of orbitals is technically infinite, this might seem tricky. Thankfully, symmetry comes to save us again, where we know from Bloch’s theorem that the linear combination should be invariant under lattice translations:</p>
<p><span class="math display">\[
\left| \vec{k}, a \right&gt; = \phi_a(\vec{r}, \vec{k}) = \frac{1}{\sqrt{N}} \sum_{n} e^{i\vec{k}\cdot\vec{R}_n} \varphi_a(\vec{r} - \vec{R}_n).
\]</span></p>
<p>You can easily show that this wave function (also called a Bloch sum) does indeed satisfy the translational invariance of the theorem, i.e.&nbsp;<span class="math inline">\(\phi_a(\vec{r} + \vec{R}_m, \vec{k}) = e^{i\vec{k}\cdot\vec{R}_m}\phi_a(\vec{r}, \vec{k})\)</span>. Using this basis, the matrix elements of the generic crystal Hamiltonian are:</p>
<p><span class="math display">\[
H_{ab}(\vec{k}) = \left&lt;\vec{k},a \right| H \left| \vec{k},b \right&gt; = \frac{1}{N} \sum_{nm} e^{-i\vec{k}\cdot (\vec{R}_m - \vec{R}_n)} \left&lt; \varphi_a (\vec{r} - \vec{R}_n) \right| H \left| \varphi_b (\vec{r} - \vec{R}_m) \right&gt;.
\]</span></p>
<p>One issue: In a crystal, the number of sites goes to infinity. So does the size of the Hamiltonian matrix. The memory on our computer, however, does not. The most common way to remedy that problem is to assume that the atoms have large spacing and the overlaps of the orbitals are <em>really</em> small. That way, only a finite amount of close neighbors have non-zero contribution. So, if we pin <span class="math inline">\(\vec{R}_m = \vec{0}\)</span> (and hide the normalization constant), the Hamiltonian matrix elements become:</p>
<p><span class="math display">\[
H_{ab} (\vec{k}) = \sum_{i} e^{i\vec{k}\cdot\vec{\delta R}_i} \left&lt; \varphi_a(\vec{r}) \right| H \left| \varphi_b(\vec{r} - \vec{\delta R}_i) \right&gt;,
\]</span></p>
<p>Where the sum now runs only over a finite number of neighbors that are separated by distances <span class="math inline">\(\{ \vec{\delta R}_i \}\)</span>. Because the integrals of type <span class="math inline">\(\left&lt; \varphi_a \right| H \left| \varphi_b \right&gt;\)</span> depend only on the crystal and orbital geometry, it is customary to parametrize the Hamiltonian in terms of on-site energies and tunneling amplitudes, as in the LCAO method:</p>
<p><span class="math display">\[
H_{ab} (\vec{k}) = \sum_{i} \delta_{ab}\mu_a - e^{i\vec{k}\cdot\vec{\delta R}_i} \, \gamma_{ab},
\]</span></p>
<p>Which is the common matrix representation of what’s known as the tight-binding Hamiltonian (called so because the electrons are tightly bound to the atomic cores).</p>
<p>The last expression gives us the full recipe for implementing the tight-binging method. The Hamiltonian consists of a diagonal that contains the on-site energies, one for each contributing orbital, and the off-diagonal hopping terms, which are non-zero only if the orbitals are close enough for the electron to tunnel between them. This way, we can pre-calculate (or pre-measure) the LCAO parameters (usually the tricky part of the solution) and do the momentum dependence on the fly, as that manifests only as a phase shift.</p>
<p>Teeechnically, the wavefunctions <span class="math inline">\(\varphi_a\)</span> don’t form an orthogonal basis, as in there’s a non-zero overlap between them, or <span class="math inline">\(\left&lt; \varphi_a | \varphi_b \right&gt; \ne \delta_{ab}\)</span>. If that’s the case, we shouldn’t be solving just a simple eigenvalue problem of type <span class="math inline">\(\hat{H} \varphi = E \varphi\)</span> but the generalized problem of <span class="math inline">\(\hat{H} \varphi = E \mathbf{S} \varphi\)</span>, where <span class="math inline">\(\mathbf{S} = S_{ab} = \left&lt; \varphi_a | \varphi_b \right&gt;\)</span> is the overlap matrix. Most libraries that can do simple eigendecomposition can also do the generalized one and if they don’t, you’re out of luck. Or just don’t calculate the overlaps between sites.</p>
<p>To implement the tight-binding scheme in code, I’ll make a bunch of helper types. Their purpose is to contain information about the terms <span class="math inline">\(\gamma\)</span>, <span class="math inline">\(\mu\)</span>, and <span class="math inline">\(S\)</span> and the relevant orbital indices.</p>
<div class="callout-warning callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Warning
</div>
</div>
<div class="callout-body-container callout-body">
<p>An important thing to keep in mind is that the computational orbital indices <code>i</code> and <code>j</code> carry both the position and atom type index. An orbital <span class="math inline">\(\phi_a\)</span> at site <span class="math inline">\(R_1\)</span> has different computational index <code>i</code> than orbital <span class="math inline">\(\phi_a\)</span> at site <span class="math inline">\(R_2\)</span>, even if the nominal index <span class="math inline">\(a\)</span> is the same and they would differ only by the offset index <span class="math inline">\(i\)</span>.</p>
</div>
</div>
<div class="cell" data-execution_count="33">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Hop</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>    γ<span class="op">::</span><span class="dt">Number</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>    i<span class="op">::</span><span class="dt">Int</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>    j<span class="op">::</span><span class="dt">Int</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>    offset<span class="op">::</span><span class="dt">Union{&lt;:Real, Array{&lt;:Real}}</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Onsite</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    μ<span class="op">::</span><span class="dt">Number</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    ii<span class="op">::</span><span class="dt">Int</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="35">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Overlap</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>    S<span class="op">::</span><span class="dt">Number</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    i<span class="op">::</span><span class="dt">Int</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    j<span class="op">::</span><span class="dt">Int</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>    offset<span class="op">::</span><span class="dt">Union{&lt;:Real, Array{&lt;:Real}}</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>And I’ll package those in a mutable type that will hold all of it in a relatively non-structured manner.</p>
<div class="cell" data-execution_count="36">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">mutable struct</span> Hoppings</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>    c<span class="op">::</span><span class="dt">Crystal</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>    γs<span class="op">::</span><span class="dt">Array{Hop}</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>    μs<span class="op">::</span><span class="dt">Array{Onsite}</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>    Ss<span class="op">::</span><span class="dt">Array{Overlap}</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>    maxij<span class="op">::</span><span class="dt">Int</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">function</span> <span class="fu">Hoppings</span>(c<span class="op">::</span><span class="dt">Crystal</span>)</span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>        <span class="fu">new</span>(c, [], [], [], <span class="fl">0</span>)</span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now I need functions to add all of the parameters where necessary.</p>
<div class="cell" data-execution_count="37">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">addhop!</span>(hops, γ, i, j, δ)</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    γ <span class="op">=</span> Unitful.<span class="fu">NoUnits</span>(γ <span class="op">/</span> Ha)</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>    offset <span class="op">=</span> δ</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">push!</span>(hops.γs, <span class="fu">Hop</span>(γ, i, j, offset))</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>    hops.maxij <span class="op">=</span> <span class="fu">max</span>(i, j, hops.maxij)</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>    hops</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="38">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">addonsite!</span>(hops, μ, ii)</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>    μ <span class="op">=</span> Unitful.<span class="fu">NoUnits</span>(μ <span class="op">/</span> Ha)</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">push!</span>(hops.μs, <span class="fu">Onsite</span>(μ, ii))</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>    hops.maxij <span class="op">=</span> <span class="fu">max</span>(hops.maxij, ii)</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>    hops</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="39">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">addoverlap!</span>(hops, S, i, j, δ)</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>    offset <span class="op">=</span> δ</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">push!</span>(hops.Ss, <span class="fu">Overlap</span>(S, i, j, offset))</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>    hops.maxij <span class="op">=</span> <span class="fu">max</span>(i, j, hops.maxij)</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>    hops</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-8-contents" aria-controls="callout-8" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Note
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-8" class="callout-8-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>only deviation from the above notation is that <span class="math inline">\(\delta R_i\)</span> became just <code>δ</code> to minimize typing.</p>
</div>
</div>
</div>
<p>Finally, we need a function that constructs the matrix representation of the tight-binding Hamiltonian out of the <code>Hoppings</code>:</p>
<div class="cell" data-execution_count="40">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">tbH</span>(k, hops<span class="op">::</span><span class="dt">Hoppings</span>)</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> hops.maxij</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>    ham <span class="op">=</span> <span class="fu">zeros</span>(<span class="dt">Complex</span>,n,n)</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    Smat <span class="op">=</span> <span class="fu">zeros</span>(<span class="dt">ComplexF64</span>,n,n)</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> hop <span class="op">∈</span> hops.γs</span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>        i, j <span class="op">=</span> hop.i, hop.j</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>        r <span class="op">=</span> hop.offset</span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>        γ <span class="op">=</span> hop.γ <span class="op">*</span> <span class="fu">exp</span>(<span class="fl">2im</span> <span class="op">*</span> <span class="cn">π</span> <span class="op">*</span> (k <span class="op">⋅</span> r))</span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>        ham[i,j] <span class="op">+=</span> γ</span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>        ham[j,i] <span class="op">+=</span> <span class="fu">conj</span>(γ)</span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> onsite <span class="op">∈</span> hops.μs</span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a>        i <span class="op">=</span> onsite.ii</span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a>        ham[i,i] <span class="op">=</span> onsite.μ</span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb43-18"><a href="#cb43-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb43-19"><a href="#cb43-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> overlap <span class="op">∈</span> hops.Ss</span>
<span id="cb43-20"><a href="#cb43-20" aria-hidden="true" tabindex="-1"></a>        i, j <span class="op">=</span> overlap.i, overlap.j</span>
<span id="cb43-21"><a href="#cb43-21" aria-hidden="true" tabindex="-1"></a>        r <span class="op">=</span> overlap.offset</span>
<span id="cb43-22"><a href="#cb43-22" aria-hidden="true" tabindex="-1"></a>        S <span class="op">=</span> overlap.S <span class="op">*</span> <span class="fu">exp</span>(<span class="fl">2im</span> <span class="op">*</span> <span class="cn">π</span> <span class="op">*</span> (k <span class="op">⋅</span> r))</span>
<span id="cb43-23"><a href="#cb43-23" aria-hidden="true" tabindex="-1"></a>        Smat[i,j] <span class="op">+=</span> S</span>
<span id="cb43-24"><a href="#cb43-24" aria-hidden="true" tabindex="-1"></a>        Smat[j,i] <span class="op">+=</span> <span class="fu">conj</span>(S)</span>
<span id="cb43-25"><a href="#cb43-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb43-26"><a href="#cb43-26" aria-hidden="true" tabindex="-1"></a>    Smat <span class="op">+=</span> <span class="fu">diagm</span>(<span class="fu">ones</span>(n))</span>
<span id="cb43-27"><a href="#cb43-27" aria-hidden="true" tabindex="-1"></a>    (ham, Smat)</span>
<span id="cb43-28"><a href="#cb43-28" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Everything here is in reduced coordinates. Since <span class="math inline">\(\vec{G}_m \cdot \vec{R}_n = 2\pi\)</span>, I can do that and still recover correct results, as long as I multiply products <span class="math inline">\(\vec{k} \cdot \vec{r}\)</span> by a factor of <span class="math inline">\(2\pi\)</span>.</p>
<p>To show how it works, let’s try a concrete example: Graphene. At first, with just the two bands that give rise to the famous photon-like dispersion.</p>
<p>I could figure out the hop directions by myself, but this can become a mess in bigger crystals (even in the case of “real” graphene we’ll do in a moment). So I make a helper function <code>unique_neighbours</code> that returns a list of nearest neighbors that’s pruned from all conjugates (hops in the opposite direction). The pruning is important because the TB Hamiltonian, being a Hamiltonian, should be hermitian (i.e.&nbsp;<span class="math inline">\(H_{ij} = H^{\dagger}_{ji}\)</span>). This is enforced during the matrix construction in <code>tbH</code>, where I generate hops in both directions at the same time just from one <code>Hop</code>.</p>
<div class="cell" data-execution_count="41">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">dedup_floats</span>(itr)</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>    out <span class="op">=</span> <span class="fu">Vector</span><span class="dt">{eltype(itr)}</span>()</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">push!</span>(out, itr[<span class="fl">1</span>])</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> itrel <span class="op">∈</span> itr</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="fu">map</span>(x <span class="op">-&gt;</span> !(itrel <span class="op">≈</span> x), out) <span class="op">|&gt;</span> all</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>            <span class="fu">push!</span>(out, itrel)</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>    out</span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">unique_neighbors</span>(c<span class="op">::</span><span class="dt">Crystal</span>)</span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a>    R <span class="op">=</span> c.lattice.R</span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a>    positions <span class="op">=</span> c.cell.positions</span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a>    supercellpositions <span class="op">=</span> <span class="fu">eltype</span>(c.cell.positions)[]</span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true" tabindex="-1"></a>    possible_hops <span class="op">=</span> []</span>
<span id="cb44-17"><a href="#cb44-17" aria-hidden="true" tabindex="-1"></a>    out <span class="op">=</span> []</span>
<span id="cb44-18"><a href="#cb44-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb44-19"><a href="#cb44-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i, ipos) <span class="op">∈</span> <span class="fu">enumerate</span>(positions)</span>
<span id="cb44-20"><a href="#cb44-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> offset <span class="op">∈</span> <span class="bu">Iterators</span>.<span class="fu">product</span>(<span class="fu">fill</span>((<span class="op">-</span><span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">1</span>), <span class="fu">ndims</span>(c.lattice))<span class="op">...</span>)</span>
<span id="cb44-21"><a href="#cb44-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> (j, jpos) <span class="op">∈</span> <span class="fu">enumerate</span>(positions)</span>
<span id="cb44-22"><a href="#cb44-22" aria-hidden="true" tabindex="-1"></a>                δ <span class="op">=</span> (jpos <span class="op">.+</span> offset) <span class="op">-</span> ipos</span>
<span id="cb44-23"><a href="#cb44-23" aria-hidden="true" tabindex="-1"></a>                    <span class="fu">push!</span>(possible_hops, (</span>
<span id="cb44-24"><a href="#cb44-24" aria-hidden="true" tabindex="-1"></a>                    i <span class="op">=</span> i, j <span class="op">=</span> j, δ <span class="op">=</span> δ,</span>
<span id="cb44-25"><a href="#cb44-25" aria-hidden="true" tabindex="-1"></a>                    ))</span>
<span id="cb44-26"><a href="#cb44-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">end</span></span>
<span id="cb44-27"><a href="#cb44-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb44-28"><a href="#cb44-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb44-29"><a href="#cb44-29" aria-hidden="true" tabindex="-1"></a>    <span class="fu">filter!</span>(v <span class="op">-&gt;</span> <span class="fu">norm</span>(v.δ) <span class="op">&gt;</span> <span class="fl">0</span>, possible_hops)</span>
<span id="cb44-30"><a href="#cb44-30" aria-hidden="true" tabindex="-1"></a>    unique_dists <span class="op">=</span> <span class="fu">map</span>(v <span class="op">-&gt;</span> (R <span class="op">*</span> v.δ) <span class="op">|&gt;</span> norm, possible_hops) <span class="op">|&gt;</span> dedup_floats <span class="op">|&gt;</span> sort</span>
<span id="cb44-31"><a href="#cb44-31" aria-hidden="true" tabindex="-1"></a>    <span class="fu">filter!</span>(v <span class="op">-&gt;</span> <span class="fu">norm</span>(R <span class="op">*</span> v.δ) <span class="op">&lt;=</span> unique_dists[<span class="fl">1</span>]<span class="fu">+eps</span>(), possible_hops)</span>
<span id="cb44-32"><a href="#cb44-32" aria-hidden="true" tabindex="-1"></a>    <span class="fu">is_conjugate</span>(u, v) <span class="op">=</span> u.i <span class="op">==</span> v.j <span class="op">&amp;&amp;</span> (u.δ <span class="op">.≈</span> <span class="op">-</span><span class="fl">1</span> <span class="op">.*</span> v.δ) <span class="op">|&gt;</span> all</span>
<span id="cb44-33"><a href="#cb44-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> hop <span class="op">∈</span> possible_hops</span>
<span id="cb44-34"><a href="#cb44-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="fu">map</span>(v <span class="op">-&gt;</span> !<span class="fu">is_conjugate</span>(v, hop), out) <span class="op">|&gt;</span> all</span>
<span id="cb44-35"><a href="#cb44-35" aria-hidden="true" tabindex="-1"></a>            <span class="fu">push!</span>(out, hop)</span>
<span id="cb44-36"><a href="#cb44-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb44-37"><a href="#cb44-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb44-38"><a href="#cb44-38" aria-hidden="true" tabindex="-1"></a>    out</span>
<span id="cb44-39"><a href="#cb44-39" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>With that, we can begin assembling the problem. First, we create an empty hopping list based on the graphene crystal structure and then we add all the hopping amplitudes between the lattice sites. If you were to write out the list of hoppings generated by the <code>unique_neighbours</code>, you’d see that there are 3 hops: one within the same unit cell (the second inequivalent site) and two from the neighboring cells.</p>
<p>We’ll scale the energy to the value of hopping amplitude <span class="math inline">\(\gamma = -1\)</span> (done by giving it energy of -1 Ha, so that everything is a multiple of unity), the minus sign is so that the “correct” band has the lower energy, even if you won’t be able to tell in this case. Because sites 1 and 2 are both just carbon, we keep <span class="math inline">\(\mu_{1,2}\)</span> as zero. Giving them a non-zero value would mean just adding the same number on the diagonal, which would manifest just as a rigid shift of the whole band structure along the energy axis (not important at the moment).</p>
<div class="cell" data-execution_count="42">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>grhops <span class="op">=</span> <span class="fu">Hoppings</span>(graphene)</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> hop <span class="op">∈</span> <span class="fu">unique_neighbors</span>(graphene)</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">addhop!</span>(grhops, <span class="op">-</span><span class="fl">1.0</span>Ha, hop.i, hop.j, hop.δ)</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>From here on, it’s the usual story: Define the trajectory in k-space and get calculatin’. The k-path will contain the customary <span class="math inline">\(\Gamma\)</span>-point, the linear dispersion is around the <span class="math inline">\(K\)</span>-point (the point where the two sides of the Brillouin zone touch), and I also throw in a <span class="math inline">\(M\)</span>-point (center of the Brillouin zone side) for good measure:</p>
<div class="cell" data-execution_count="43">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>grks <span class="op">=</span> <span class="fu">kpath</span>([</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span>Γ <span class="op">=&gt;</span> [<span class="fl">0</span>,<span class="fl">0</span>],</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span>M <span class="op">=&gt;</span> [<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>,<span class="fl">0</span>],</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span>K <span class="op">=&gt;</span> [<span class="fl">1</span><span class="op">/</span><span class="fl">3</span>,<span class="fl">1</span><span class="op">/</span><span class="fl">3</span>],</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span>Γ <span class="op">=&gt;</span> [<span class="fl">0</span>,<span class="fl">0</span>]</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>        ], <span class="fl">0.01</span>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we just construct the hamiltonian and calculate eigenvalues along the k-space trajectory:</p>
<div class="cell" data-execution_count="44">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="fu">grtbH</span>(k) <span class="op">=</span> <span class="fu">tbH</span>(k, grhops)</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>gres <span class="op">=</span> <span class="fu">grtbH</span>.(grks.path) <span class="op">.|&gt;</span> first <span class="op">.|&gt;</span> eigvals;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>And plot:</p>
<div class="cell" data-execution_count="45">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>fig_gr <span class="op">=</span> <span class="fu">Figure</span>()</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>ax_gr <span class="op">=</span> <span class="fu">Axis</span>(fig_gr)</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>ax_gr.xticks <span class="op">=</span> ([p.second for p <span class="op">∈</span> grks.ppoints], </span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>                [<span class="fu">string</span>(p.first) for p <span class="op">∈</span> grks.ppoints])</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>ax_gr.yticks <span class="op">=</span> <span class="op">-</span><span class="fl">3</span><span class="op">:</span><span class="fl">3</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>ax_gr.ylabel <span class="op">=</span> <span class="st">"E/γ"</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a><span class="fu">xlims!</span>(ax_gr, (<span class="fl">0</span>, grks.plength[<span class="kw">end</span>]))</span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a><span class="fu">hideydecorations!</span>(ax_gr, ticks<span class="op">=</span><span class="cn">false</span>, ticklabels<span class="op">=</span><span class="cn">false</span>, label<span class="op">=</span><span class="cn">false</span>)</span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n <span class="op">∈</span> <span class="fl">1</span><span class="op">:</span><span class="fu">length</span>(gres[<span class="fl">1</span>])</span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">lines!</span>(grks.plength, [<span class="cn">e</span>[n] for <span class="cn">e</span> <span class="op">∈</span> gres])</span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a>fig_gr[<span class="fl">1</span>,<span class="fl">1</span>] <span class="op">=</span> ax_gr</span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a><span class="fu">current_figure</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="186">
<p><img src="index_files/figure-html/cell-46-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Because this tight-binding Hamiltonian has the form <span class="math inline">\(H =\begin{bmatrix} 0 &amp; \Gamma(k) \\ \Gamma^*(k) &amp; 0 \\ \end{bmatrix}\)</span>, we can analytically solve for the energies and would find out that <span class="math inline">\(E_{\pm} = \pm |\Gamma(k)|\)</span>. At the <span class="math inline">\(K\)</span>-points, the elements <span class="math inline">\(\Gamma(K) = 0\)</span>, and the energy of both bands goes to zero. At distance close to the <span class="math inline">\(K\)</span>-point, you can do a Taylor expansion to the first order, and you’d end up with a <a href="http://ahrenkiel.sdsmt.edu/courses/Fall2019/NANO702/lectures/13_DiracEquation_Graphene/Nano%20702%20lecX%20112117.pdf">somewhat of a Dirac equation</a> and a dispersion relation <span class="math inline">\(E(k \approx K) = \Gamma(k) \propto k\)</span> characteristic for massless particles, where <span class="math inline">\(E(k) = \hbar c k\)</span>.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> I guess this is why the band structure around the <span class="math inline">\(K\)</span>-point is called a Dirac cone and why people say that the electrons at these momenta are photon-like.</p>
<p>If we were to do this calculation with hexagonal Boron Nitride, we would have to add onsite energies that are different for the two different lattice sites. This presence of non-trivial diagonal terms in the Hamiltonian would lead to a non-zero separation of energies when <span class="math inline">\(\Gamma(k) = 0\)</span>, which opens a band gap and curves the bands.</p>
</section>
<section id="sec-cmpm3-tbGR" class="level2">
<h2 class="anchored" data-anchor-id="sec-cmpm3-tbGR">Digging deeper</h2>
<p>The above plot looks good but the physical interpretation is lacking. The band diagram looks like it does because I claim that there are only two equivalent orbitals participating, which is often simply stated in textbooks and might seem suspect based on the fact that carbon has more than one valence electron. While I’m all for dictating how nature should do things, there’s a certain beauty to making predictions that work not because they do, but because they should. To show why graphene should have these bands, let’s drop the empirical approach and try to do a first principles-ish calculation by doing tight-binding with real carbon atomic orbitals.</p>
<p>Let’s first look at the orbital wavefunctions. Central potential problems, like those of hydrogen-like atoms, are usually solved in spherical coordinates, so I’ll quickly throw together some helper functions to convert cartesian coords:</p>
<div class="cell" data-execution_count="46">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">to_polar</span>(r)</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>    x,y,z <span class="op">=</span> r</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> <span class="fu">norm</span>(r)</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>    θ <span class="op">=</span> <span class="fu">ifelse</span>(r <span class="op">!=</span> <span class="fl">0</span>, <span class="fu">acos</span>(z<span class="op">/</span>r), <span class="fl">0.0</span>)</span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>    <span class="cn">φ</span> <span class="op">=</span> <span class="cf">if</span> x <span class="op">&gt;</span> <span class="fl">0</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>        <span class="fu">atan</span>(y<span class="op">/</span>x)</span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elseif</span> x <span class="op">&lt;</span> <span class="fl">0</span></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>        <span class="fu">atan</span>(y<span class="op">/</span>x) <span class="op">+</span> <span class="cn">π</span></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>        <span class="cn">π</span><span class="op">/</span><span class="fl">2</span></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>    [r,θ,<span class="cn">φ</span>]</span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The general form for the eigenfunctions is a product of <a href="https://en.wikipedia.org/wiki/Laguerre_polynomials#Generalized_Laguerre_polynomials">Laguerre polynomials</a> and <a href="https://en.wikipedia.org/wiki/Spherical_harmonics">spherical harmonics</a> but because we’re limiting ourselves just to the <span class="math inline">\(n = 2\)</span> states, I can write down the specific form in our atomic units: <span class="math inline">\(\phi(\vec{r})_{2s} = \frac{1}{4\sqrt{2\pi}} (2 - r) e^{-r/2}\)</span>, <span class="math inline">\(\phi(\vec{r})_{2p,m_l=0} = \frac{1}{4\sqrt{2\pi}} r e^{-r/2} \cos{(\theta)}\)</span> and <span class="math inline">\(\phi(\vec{r})_{2p,m_l=\pm 1} = \frac{\mp 1}{8\sqrt{\pi}} r e^{-r/2} \sin(\theta) e^{\pm i \varphi}\)</span>, where I separated the cases of the magnetic quantum number <span class="math inline">\(m_l=0\)</span> and <span class="math inline">\(m_l=\pm1\)</span> (the choice for identification of the latter is arbitrary, you just need the two <span class="math inline">\(m_l=\pm1\)</span> have opposite signs so that they’re orthogonal).</p>
<div class="cell" data-execution_count="47">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">ψ2s</span>(r)</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>    r,θ,<span class="cn">φ</span> <span class="op">=</span> <span class="fu">to_polar</span>(r)</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>    <span class="fl">1</span><span class="op">/</span>(<span class="fl">4</span><span class="fu">*sqrt</span>(<span class="fl">2</span>π)) <span class="op">*</span> (<span class="fl">2</span> <span class="op">-</span> r) <span class="op">*</span> <span class="fu">exp</span>(<span class="op">-</span>r<span class="op">/</span><span class="fl">2</span>) <span class="op">+</span> <span class="fl">0im</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="48">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">ψ2p</span>(r, ml)</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>    r,θ,<span class="cn">φ</span> <span class="op">=</span> <span class="fu">to_polar</span>(r)</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">ifelse</span>(ml <span class="op">==</span> <span class="fl">0</span>,</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>        <span class="fl">1</span><span class="op">/</span>(<span class="fl">4</span><span class="fu">*sqrt</span>(<span class="fl">2</span>π)) <span class="op">*</span> r <span class="op">*</span> <span class="fu">exp</span>(<span class="op">-</span>r<span class="op">/</span><span class="fl">2</span>) <span class="op">*</span> <span class="fu">cos</span>(θ) <span class="op">+</span> <span class="fl">0im</span>,</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">-</span>ml<span class="op">/</span>(<span class="fl">8</span><span class="fu">*sqrt</span>(<span class="fl">2</span>π)) <span class="op">*</span> r <span class="op">*</span> <span class="fu">exp</span>(<span class="op">-</span>r<span class="op">/</span><span class="fl">2</span>) <span class="op">*</span> <span class="fu">sin</span>(θ) <span class="op">*</span> <span class="fu">exp</span>(<span class="fl">1im</span> <span class="op">*</span> ml <span class="op">*</span> <span class="cn">φ</span>)</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The <span class="math inline">\(m_l = 0\)</span> orbital is recognizably the <span class="math inline">\(p_z\)</span> orbital you know from textbooks:</p>
<div class="cell" data-execution_count="49">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>foo <span class="op">=</span> [<span class="fu">ψ2p</span>([i,j,k], <span class="fl">0</span>) <span class="op">|&gt;</span> abs2 for i <span class="op">∈</span> <span class="op">-</span><span class="fl">3</span><span class="op">:</span><span class="fl">0.1</span><span class="op">:</span><span class="fl">3</span>, j <span class="op">∈</span> <span class="op">-</span><span class="fl">3</span><span class="op">:</span><span class="fl">0.1</span><span class="op">:</span><span class="fl">3</span>, k <span class="op">∈</span> <span class="op">-</span><span class="fl">5</span><span class="op">:</span><span class="fl">0.1</span><span class="op">:</span><span class="fl">5</span>]</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="fu">contour</span>(foo, levels<span class="op">=</span><span class="fl">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="190">
<p><img src="index_files/figure-html/cell-50-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>The other two might not be what you expect if your knowledge of atomic orbitals comes from chemistry:</p>
<div class="cell" data-execution_count="50">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>foo <span class="op">=</span> [<span class="fu">ψ2p</span>([i,j,k], <span class="fl">1</span>) <span class="op">|&gt;</span> abs2 for i <span class="op">∈</span> <span class="op">-</span><span class="fl">5</span><span class="op">:</span><span class="fl">0.1</span><span class="op">:</span><span class="fl">5</span>, j <span class="op">∈</span> <span class="op">-</span><span class="fl">5</span><span class="op">:</span><span class="fl">0.1</span><span class="op">:</span><span class="fl">5</span>, k <span class="op">∈</span> <span class="op">-</span><span class="fl">4</span><span class="op">:</span><span class="fl">0.1</span><span class="op">:</span><span class="fl">4</span>]</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a><span class="fu">contour</span>(foo, levels<span class="op">=</span><span class="fl">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="191">
<p><img src="index_files/figure-html/cell-51-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>That’s not the dumbbell shape that you’re <a href="http://www.chem.ucla.edu/~harding/IGOC/P/p_orbital02.png">usually shown</a>. It is the correct solution to the radial Schroedinger equation, so why are we getting a donut? Well, it’s because of conventions. If the eigenfunctions <span class="math inline">\(\left| p_{-1} \right&gt;,\left| p_{1} \right&gt;,\left| p_{0} \right&gt;\)</span> are solutions to the Schroedinger equation (which they are, that’s why they’re eigenfunctions), then so is any of their linear combinations. Because the purely real dumbbell-shaped functions are more convenient when discussing chemical bonds and symmetries of crystals, it is customary to rotate the <span class="math inline">\(\{\left| p_{m_l} \right&gt; \}_{m_l={-1,1,0}}\)</span> basis into a different basis <span class="math inline">\(\{ \left| p_{r} \right&gt; \}_{r={x,y,z}}\)</span>, where <span class="math inline">\(\left| p_{x} \right&gt;\)</span> and <span class="math inline">\(\left| p_{y} \right&gt;\)</span> (also known as cubic harmonics) are linear combinations of <span class="math inline">\(\left| p_{-1} \right&gt;\)</span> and <span class="math inline">\(\left| p_{1} \right&gt;\)</span>:</p>
<div class="cell" data-execution_count="51">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">ψ2pz</span>(r)</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>    r,θ,<span class="cn">φ</span> <span class="op">=</span> <span class="fu">to_polar</span>(r)</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>    <span class="fl">1</span><span class="op">/</span>(<span class="fl">4</span><span class="fu">*sqrt</span>(<span class="fl">2</span>π)) <span class="op">*</span> r <span class="op">*</span> <span class="fu">exp</span>(<span class="op">-</span>r<span class="op">/</span><span class="fl">2</span>) <span class="op">*</span> <span class="fu">cos</span>(θ) <span class="op">+</span> <span class="fl">0im</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">ψ2px</span>(r)</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>    r,θ,<span class="cn">φ</span> <span class="op">=</span> <span class="fu">to_polar</span>(r)</span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>    <span class="fl">1</span><span class="op">/</span>(<span class="fl">4</span><span class="fu">*sqrt</span>(<span class="fl">2</span>π)) <span class="op">*</span> r <span class="op">*</span> <span class="fu">exp</span>(<span class="op">-</span>r<span class="op">/</span><span class="fl">2</span>) <span class="op">*</span> <span class="fu">sin</span>(θ) <span class="op">*</span> <span class="fu">cos</span>(<span class="cn">φ</span>) <span class="op">+</span> <span class="fl">0im</span></span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">ψ2py</span>(r)</span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a>    r,θ,<span class="cn">φ</span> <span class="op">=</span> <span class="fu">to_polar</span>(r)</span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a>    <span class="fl">1</span><span class="op">/</span>(<span class="fl">4</span><span class="fu">*sqrt</span>(<span class="fl">2</span>π)) <span class="op">*</span> r <span class="op">*</span> <span class="fu">exp</span>(<span class="op">-</span>r<span class="op">/</span><span class="fl">2</span>) <span class="op">*</span> <span class="fu">sin</span>(θ) <span class="op">*</span> <span class="fu">sin</span>(<span class="cn">φ</span>) <span class="op">+</span> <span class="fl">0im</span></span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now the <span class="math inline">\(p_x\)</span> and <span class="math inline">\(p_y\)</span> orbitals have the shape you’re used to:</p>
<div class="cell" data-execution_count="52">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>foox <span class="op">=</span> [<span class="fu">ψ2px</span>([i,j,k]) <span class="op">|&gt;</span> abs2 for i <span class="op">∈</span> <span class="op">-</span><span class="fl">5</span><span class="op">:</span><span class="fl">0.1</span><span class="op">:</span><span class="fl">5</span>, j <span class="op">∈</span> <span class="op">-</span><span class="fl">3</span><span class="op">:</span><span class="fl">0.1</span><span class="op">:</span><span class="fl">3</span>, k <span class="op">∈</span> <span class="op">-</span><span class="fl">3</span><span class="op">:</span><span class="fl">0.1</span><span class="op">:</span><span class="fl">3</span>]</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="fu">contour</span>(foox, levels<span class="op">=</span><span class="fl">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="193">
<p><img src="index_files/figure-html/cell-53-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>When thrown together, they form a nice symmetric structure:</p>
<div class="cell" data-execution_count="53">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> <span class="fu">Figure</span>()</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>l <span class="op">=</span> <span class="fl">3.4</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> <span class="fl">3.4</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>hybp <span class="op">=</span> <span class="fu">Axis3</span>(f[<span class="fl">1</span>, <span class="fl">1</span>], aspect<span class="op">=</span>(<span class="fl">1</span>.,<span class="fl">1</span>.,z<span class="op">/</span>l), elevation<span class="op">=</span><span class="fl">0.2</span>π, azimuth<span class="op">=</span><span class="fl">0.2</span>π)</span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>foox <span class="op">=</span> [<span class="fu">ψ2px</span>([i,j,k]) <span class="op">|&gt;</span> abs2 for i <span class="op">∈</span> <span class="op">-</span>l<span class="op">:</span><span class="fl">0.1</span><span class="op">:</span>l, j <span class="op">∈</span> <span class="op">-</span>l<span class="op">:</span><span class="fl">0.1</span><span class="op">:</span>l, k <span class="op">∈</span> <span class="op">-</span>z<span class="op">:</span><span class="fl">0.1</span><span class="op">:</span>z]</span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>fooy <span class="op">=</span> [<span class="fu">ψ2py</span>([i,j,k]) <span class="op">|&gt;</span> abs2 for i <span class="op">∈</span> <span class="op">-</span>l<span class="op">:</span><span class="fl">0.1</span><span class="op">:</span>l, j <span class="op">∈</span> <span class="op">-</span>l<span class="op">:</span><span class="fl">0.1</span><span class="op">:</span>l, k <span class="op">∈</span> <span class="op">-</span>z<span class="op">:</span><span class="fl">0.1</span><span class="op">:</span>z]</span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a>fooz <span class="op">=</span> [<span class="fu">ψ2pz</span>([i,j,k]) <span class="op">|&gt;</span> abs2 for i <span class="op">∈</span> <span class="op">-</span>l<span class="op">:</span><span class="fl">0.1</span><span class="op">:</span>l, j <span class="op">∈</span> <span class="op">-</span>l<span class="op">:</span><span class="fl">0.1</span><span class="op">:</span>l, k <span class="op">∈</span> <span class="op">-</span>z<span class="op">:</span><span class="fl">0.1</span><span class="op">:</span>z]</span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a>foos <span class="op">=</span> [<span class="fu">ψ2s</span>([i,j,k]) <span class="op">|&gt;</span> abs2 for i <span class="op">∈</span> <span class="op">-</span>l<span class="op">:</span><span class="fl">0.1</span><span class="op">:</span>l, j <span class="op">∈</span> <span class="op">-</span>l<span class="op">:</span><span class="fl">0.1</span><span class="op">:</span>l, k <span class="op">∈</span> <span class="op">-</span>z<span class="op">:</span><span class="fl">0.1</span><span class="op">:</span>z]</span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a><span class="fu">contour!</span>(foox, levels<span class="op">=</span>[<span class="fl">4e-3</span>])</span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a><span class="fu">contour!</span>(fooy, levels<span class="op">=</span>[<span class="fl">4e-3</span>])</span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true" tabindex="-1"></a><span class="fu">contour!</span>(fooz, levels<span class="op">=</span>[<span class="fl">4e-3</span>])</span>
<span id="cb56-13"><a href="#cb56-13" aria-hidden="true" tabindex="-1"></a><span class="fu">contour!</span>(foos, levels<span class="op">=</span>[<span class="fl">4e-3</span>])</span>
<span id="cb56-14"><a href="#cb56-14" aria-hidden="true" tabindex="-1"></a><span class="fu">hidedecorations!</span>(hybp, label<span class="op">=</span><span class="cn">false</span>)</span>
<span id="cb56-15"><a href="#cb56-15" aria-hidden="true" tabindex="-1"></a><span class="fu">current_figure</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="194">
<p><img src="index_files/figure-html/cell-54-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>With one obvious issue: That is not the trigonal symmetry of graphene. What actually happens, is that the <span class="math inline">\(2s\)</span>, <span class="math inline">\(2p_x\)</span>, and <span class="math inline">\(2p_y\)</span> orbitals undergo hybridization: By the same argument used for the formation of the cubic harmonics, you can mix the one <span class="math inline">\(2s\)</span> and two <span class="math inline">\(2p\)</span> orbitals to form a trigonal structure with lopsided orbitals extending outwards from the center, rotated by 120 degrees:</p>
<div class="cell" data-execution_count="54">
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ψ1</span>(r) <span class="op">=</span> <span class="fl">1</span><span class="op">/</span><span class="fu">√</span>(<span class="fl">3</span>)<span class="fu">*ψ2s</span>(r) <span class="op">+</span> <span class="fl">1</span><span class="op">/</span><span class="fu">√</span>(<span class="fl">6</span>) <span class="op">*</span> <span class="fu">ψ2px</span>(r) <span class="op">+</span> <span class="fl">1</span><span class="op">/</span><span class="fu">√</span>(<span class="fl">2</span>) <span class="op">*</span> <span class="fu">ψ2py</span>(r)</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="fu">ψ2</span>(r) <span class="op">=</span> <span class="fl">1</span><span class="op">/</span><span class="fu">√</span>(<span class="fl">3</span>)<span class="fu">*ψ2s</span>(r) <span class="op">+</span> <span class="fl">1</span><span class="op">/</span><span class="fu">√</span>(<span class="fl">6</span>) <span class="op">*</span> <span class="fu">ψ2px</span>(r) <span class="op">-</span> <span class="fl">1</span><span class="op">/</span><span class="fu">√</span>(<span class="fl">2</span>) <span class="op">*</span> <span class="fu">ψ2py</span>(r)</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a><span class="fu">ψ3</span>(r) <span class="op">=</span> <span class="fl">1</span><span class="op">/</span><span class="fu">√</span>(<span class="fl">3</span>)<span class="fu">*ψ2s</span>(r) <span class="op">-</span> <span class="fl">2</span><span class="op">/</span><span class="fl">3</span> <span class="op">*</span> <span class="fu">ψ2px</span>(r)</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>l <span class="op">=</span> <span class="fl">3</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> <span class="fl">2</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> <span class="fu">Figure</span>()</span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>hybp <span class="op">=</span> <span class="fu">Axis3</span>(f[<span class="fl">1</span>, <span class="fl">1</span>], aspect<span class="op">=</span>(<span class="fl">1</span>.,<span class="fl">1</span>.,l<span class="op">/</span>z), elevation<span class="op">=</span><span class="fl">0.2</span>π, azimuth<span class="op">=</span><span class="fl">0.2</span>π)</span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a>l <span class="op">=</span> <span class="fl">1</span></span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a>foo1 <span class="op">=</span> [<span class="fu">ψ1</span>([i,j,k]) <span class="op">|&gt;</span> abs2 for i <span class="op">∈</span> <span class="op">-</span>l<span class="op">:</span><span class="fl">0.1</span><span class="op">:</span>l, j <span class="op">∈</span> <span class="op">-</span>l<span class="op">:</span><span class="fl">0.1</span><span class="op">:</span>l, k <span class="op">∈</span> <span class="op">-</span>z<span class="op">:</span><span class="fl">0.1</span><span class="op">:</span>z]</span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true" tabindex="-1"></a>foo2 <span class="op">=</span> [<span class="fu">ψ2</span>([i,j,k]) <span class="op">|&gt;</span> abs2 for i <span class="op">∈</span> <span class="op">-</span>l<span class="op">:</span><span class="fl">0.1</span><span class="op">:</span>l, j <span class="op">∈</span> <span class="op">-</span>l<span class="op">:</span><span class="fl">0.1</span><span class="op">:</span>l, k <span class="op">∈</span> <span class="op">-</span>z<span class="op">:</span><span class="fl">0.1</span><span class="op">:</span>z]</span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true" tabindex="-1"></a>foo3 <span class="op">=</span> [<span class="fu">ψ3</span>([i,j,k]) <span class="op">|&gt;</span> abs2 for i <span class="op">∈</span> <span class="op">-</span>l<span class="op">:</span><span class="fl">0.1</span><span class="op">:</span>l, j <span class="op">∈</span> <span class="op">-</span>l<span class="op">:</span><span class="fl">0.1</span><span class="op">:</span>l, k <span class="op">∈</span> <span class="op">-</span>z<span class="op">:</span><span class="fl">0.1</span><span class="op">:</span>z]</span>
<span id="cb57-14"><a href="#cb57-14" aria-hidden="true" tabindex="-1"></a>fooz <span class="op">=</span> [<span class="fu">ψ2pz</span>([i,j,k]) <span class="op">|&gt;</span> abs2 for i <span class="op">∈</span> <span class="op">-</span>l<span class="op">:</span><span class="fl">0.1</span><span class="op">:</span>l, j <span class="op">∈</span> <span class="op">-</span>l<span class="op">:</span><span class="fl">0.1</span><span class="op">:</span>l, k <span class="op">∈</span> <span class="op">-</span>z<span class="op">:</span><span class="fl">0.1</span><span class="op">:</span>z]</span>
<span id="cb57-15"><a href="#cb57-15" aria-hidden="true" tabindex="-1"></a><span class="fu">contour!</span>(foo1 <span class="op">./</span> <span class="fu">maximum</span>(foo1), levels<span class="op">=</span>[<span class="fl">0.6</span>])</span>
<span id="cb57-16"><a href="#cb57-16" aria-hidden="true" tabindex="-1"></a><span class="fu">contour!</span>(foo2 <span class="op">./</span> <span class="fu">maximum</span>(foo2), levels<span class="op">=</span>[<span class="fl">0.6</span>])</span>
<span id="cb57-17"><a href="#cb57-17" aria-hidden="true" tabindex="-1"></a><span class="fu">contour!</span>(foo3 <span class="op">./</span> <span class="fu">maximum</span>(foo3), levels<span class="op">=</span>[<span class="fl">0.6</span>])</span>
<span id="cb57-18"><a href="#cb57-18" aria-hidden="true" tabindex="-1"></a><span class="fu">contour!</span>(fooz, levels<span class="op">=</span>[<span class="fl">5e-3</span>])</span>
<span id="cb57-19"><a href="#cb57-19" aria-hidden="true" tabindex="-1"></a><span class="fu">hidedecorations!</span>(hybp, label<span class="op">=</span><span class="cn">false</span>)</span>
<span id="cb57-20"><a href="#cb57-20" aria-hidden="true" tabindex="-1"></a><span class="fu">current_figure</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="195">
<p><img src="index_files/figure-html/cell-55-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Because the 2-dimensional graphene sheet doesn’t have a translational symmetry along the z-axis, the <span class="math inline">\(2p_z\)</span> orbitals keep their shape. This can be seen from calculating the overlap integrals <span class="math inline">\(\left&lt; 2p_z | \phi \right&gt;\)</span> which are equal to 0 for <span class="math inline">\(\left| \phi \right&gt; = \left| 2p_{x,y} \right&gt;\)</span> or <span class="math inline">\(\left| 2s \right&gt;\)</span> at the same site because they are orthogonal, and also equal to zero when overlapping from different sites, because everything else lies in plane <span class="math inline">\(z=0\)</span>, over which the <span class="math inline">\(|2p_z&gt;\)</span> is anti-symmetric (any contribution from <span class="math inline">\(z&gt;0\)</span> will be exactly cancelled by contributions from <span class="math inline">\(z&lt;0\)</span>).</p>
<p>This is known as <a href="https://en.wikipedia.org/wiki/Orbital_hybridisation#sp2"><span class="math inline">\(sp^2\)</span> hybridization</a>, named so because 2 of the <span class="math inline">\(2p\)</span> orbitals participate in it (if we were working with a diamond, all orbitals would undergo a <span class="math inline">\(sp^3\)</span> hybridization, forming a tetrahedral structure).</p>
<p>But solving the whole problem by just symmetry arguments is not what I want to do here. Let’s pretend we don’t know anything about hybridization and prepare the crystal with the 4 regular cubic harmonics sitting at each site:</p>
<div class="cell" data-execution_count="55">
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>orbs <span class="op">=</span> [</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>    (<span class="op">:</span>s, [<span class="fl">2</span><span class="op">/</span><span class="fl">3</span>, <span class="fl">1</span><span class="op">/</span><span class="fl">3</span>]),  <span class="co">#1</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>    (<span class="op">:</span>s, [<span class="fl">1</span><span class="op">/</span><span class="fl">3</span>, <span class="fl">2</span><span class="op">/</span><span class="fl">3</span>]),  <span class="co">#2</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">###</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>    (<span class="op">:</span>px, [<span class="fl">2</span><span class="op">/</span><span class="fl">3</span>, <span class="fl">1</span><span class="op">/</span><span class="fl">3</span>]), <span class="co">#3</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>    (<span class="op">:</span>px, [<span class="fl">1</span><span class="op">/</span><span class="fl">3</span>, <span class="fl">2</span><span class="op">/</span><span class="fl">3</span>]), <span class="co">#4</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">###</span></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>    (<span class="op">:</span>py, [<span class="fl">2</span><span class="op">/</span><span class="fl">3</span>, <span class="fl">1</span><span class="op">/</span><span class="fl">3</span>]), <span class="co">#5</span></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>    (<span class="op">:</span>py, [<span class="fl">1</span><span class="op">/</span><span class="fl">3</span>, <span class="fl">2</span><span class="op">/</span><span class="fl">3</span>]), <span class="co">#6</span></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">###</span></span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a>    (<span class="op">:</span>pz, [<span class="fl">2</span><span class="op">/</span><span class="fl">3</span>, <span class="fl">1</span><span class="op">/</span><span class="fl">3</span>]), <span class="co">#7</span></span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a>    (<span class="op">:</span>pz, [<span class="fl">1</span><span class="op">/</span><span class="fl">3</span>, <span class="fl">2</span><span class="op">/</span><span class="fl">3</span>]), <span class="co">#8</span></span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a>];</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="56">
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>grorbs <span class="op">=</span> <span class="fu">Crystal</span>(</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">Lattice</span>(<span class="fl">2.468</span>Å, <span class="fl">2.468</span>Å, <span class="fl">120</span>),</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">UnitCell</span>([<span class="fu">first</span>(orb) for orb <span class="op">∈</span> orbs], (<span class="fu">last</span>(orb) <span class="cf">for</span> orb <span class="op">∈</span> orbs)<span class="op">...</span>)</span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now comes the fun part. There are 48 non-conjugate hops and 2 different on-site energies (one for <span class="math inline">\(2s\)</span> and <span class="math inline">\(2p\)</span> at each site), leading to a Hamiltonian with 50 free parameters, which is about 40 too many for practical purposes. Fortunately, the integrals of type <span class="math inline">\(\left&lt; \phi_1 \right| \hat{H} \left| \phi_2 \right&gt;\)</span> can be nicely factored if the <span class="math inline">\(\left| \phi \right&gt;\)</span>s are cubic harmonics, as was shown by <a href="https://doi.org/10.1103%2FPhysRev.94.1498">Slater and Koster</a> (non-paywalled article <a href="http://users.wfu.edu/natalie/s15phy752/lecturenote/SlaterKoster.PhysRev.94.1498.pdf">here</a>). Looking at the <a href="https://en.wikipedia.org/wiki/Tight_binding#Table_of_interatomic_matrix_elements">abridged list at Wikipedia</a>, you see that we need only two sets of four numbers and the displacement vector of the orbitals corresponding to each hop. The values are for integrals between two <span class="math inline">\(s\)</span>-type orbitals labeled <span class="math inline">\(ss\sigma\)</span>, an <span class="math inline">\(s\)</span>-type and <span class="math inline">\(p\)</span>-type orbital labeled <span class="math inline">\(sp\sigma\)</span>, two <span class="math inline">\(p\)</span>-type orbitals in the same plane (<span class="math inline">\(pp\sigma\)</span>), and two <span class="math inline">\(p\)</span>-type orbitals extending in planes perpendicular to each other (<span class="math inline">\(pp\pi\)</span>). This is known as the Slater-Koster (SK) parametrization and it reduces the number of free parameters down to 10 in our case.</p>
<p>And this is where the tight-binding methods really shine. You can do a computationally heavy calculation (e.g., DFT) or measurement (say, photoemission) of the band energies at a few select momentum values and then fit the parameters to these known energy values. After that, you can quickly churn out the band structure all across the k-space, or add some more physics to it if you so please.</p>
<p>To nobody’s surprise, this was <a href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.82.245412">already done for graphene</a> (<a href="https://wiki.physics.udel.edu/wiki_qttg/images/9/99/FABIAN%3Dtight_binding_theory_of_spin_orbit_coupling_in_graphene.pdf">non-paywall</a>), so I can just extract the numbers:</p>
<div class="cell" data-execution_count="57">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>hopping_ints <span class="op">=</span> <span class="fu">Dict</span>(</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">:</span>ssσ <span class="op">=&gt;</span> <span class="op">-</span><span class="fl">5.729</span>eV,</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">:</span>spσ <span class="op">=&gt;</span> <span class="fl">5.618</span>eV,</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">:</span>ppσ <span class="op">=&gt;</span> <span class="fl">6.050</span>eV,</span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">:</span>ppπ <span class="op">=&gt;</span> <span class="op">-</span><span class="fl">3.070</span>eV</span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>onsite_es <span class="op">=</span> <span class="fu">Dict</span>(</span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">:</span>s <span class="op">=&gt;</span> <span class="op">-</span><span class="fl">8.37</span>eV,</span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">:</span>p <span class="op">=&gt;</span> <span class="fl">0</span>eV</span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a>overlap_vals <span class="op">=</span> <span class="fu">Dict</span>(</span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">:</span>ssσ <span class="op">=&gt;</span> <span class="fl">0.102</span>,</span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">:</span>spσ <span class="op">=&gt;</span> <span class="op">-</span><span class="fl">0.171</span>,</span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">:</span>ppσ <span class="op">=&gt;</span> <span class="op">-</span><span class="fl">0.377</span>,</span>
<span id="cb60-15"><a href="#cb60-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">:</span>ppπ <span class="op">=&gt;</span> <span class="fl">0.070</span></span>
<span id="cb60-16"><a href="#cb60-16" aria-hidden="true" tabindex="-1"></a>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>With that, we start feeding our code the values (I use <a href="https://en.wikipedia.org/wiki/Pattern_matching">pattern matching</a> with the <code>@match</code> macro to avoid horribly nested if-else statements):</p>
<div class="cell" data-execution_count="58">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>gr2hops <span class="op">=</span> <span class="fu">Hoppings</span>(grorbs)</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a><span class="fu">dir_cos</span>(r) <span class="op">=</span> r <span class="op">./</span> <span class="fu">norm</span>(r)</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> hop <span class="op">∈</span> <span class="fu">unique_neighbors</span>(grorbs)</span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>    orb_types <span class="op">=</span> (orbs[hop.i][<span class="fl">1</span>], orbs[hop.j][<span class="fl">1</span>])</span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>    l, m <span class="op">=</span> <span class="fu">dir_cos</span>(grorbs.lattice.R <span class="op">*</span> hop.δ)</span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>    γ <span class="op">=</span> <span class="pp">@match</span> orb_types <span class="cf">begin</span></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>        (<span class="op">:</span>s, <span class="op">:</span>s)   <span class="op">=&gt;</span> hopping_ints[<span class="op">:</span>ssσ]</span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>        (<span class="op">:</span>s, <span class="op">:</span>px)  <span class="op">=&gt;</span> l <span class="op">*</span> hopping_ints[<span class="op">:</span>spσ]</span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>        (<span class="op">:</span>s, <span class="op">:</span>py)  <span class="op">=&gt;</span> m <span class="op">*</span> hopping_ints[<span class="op">:</span>spσ]</span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">#(:s, :pz) =&gt; 0.</span></span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a>        (<span class="op">:</span>px, <span class="op">:</span>s)  <span class="op">=&gt;</span> l <span class="op">*</span> hopping_ints[<span class="op">:</span>spσ]</span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a>        (<span class="op">:</span>px, <span class="op">:</span>px) <span class="op">=&gt;</span> l<span class="op">^</span><span class="fl">2</span> <span class="op">*</span> hopping_ints[<span class="op">:</span>ppσ] <span class="op">+</span> (<span class="fl">1</span><span class="op">-</span>l<span class="op">^</span><span class="fl">2</span>) <span class="op">*</span> hopping_ints[<span class="op">:</span>ppπ]</span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true" tabindex="-1"></a>        (<span class="op">:</span>px, <span class="op">:</span>py) <span class="op">=&gt;</span> l<span class="op">*</span>m <span class="op">*</span> (hopping_ints[<span class="op">:</span>ppσ] <span class="op">-</span> hopping_ints[<span class="op">:</span>ppπ])</span>
<span id="cb61-15"><a href="#cb61-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">#(:px, :pz) =&gt; 0.</span></span>
<span id="cb61-16"><a href="#cb61-16" aria-hidden="true" tabindex="-1"></a>        (<span class="op">:</span>py, <span class="op">:</span>s)  <span class="op">=&gt;</span> m <span class="op">*</span> hopping_ints[<span class="op">:</span>spσ]</span>
<span id="cb61-17"><a href="#cb61-17" aria-hidden="true" tabindex="-1"></a>        (<span class="op">:</span>py, <span class="op">:</span>px) <span class="op">=&gt;</span> l<span class="op">*</span>m <span class="op">*</span> (hopping_ints[<span class="op">:</span>ppσ] <span class="op">-</span> hopping_ints[<span class="op">:</span>ppπ])</span>
<span id="cb61-18"><a href="#cb61-18" aria-hidden="true" tabindex="-1"></a>        (<span class="op">:</span>py, <span class="op">:</span>py) <span class="op">=&gt;</span> m<span class="op">^</span><span class="fl">2</span> <span class="op">*</span> hopping_ints[<span class="op">:</span>ppσ] <span class="op">+</span> (<span class="fl">1</span><span class="op">-</span>m<span class="op">^</span><span class="fl">2</span>) <span class="op">*</span> hopping_ints[<span class="op">:</span>ppπ]</span>
<span id="cb61-19"><a href="#cb61-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">#(:py, :pz) =&gt; 0.</span></span>
<span id="cb61-20"><a href="#cb61-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">#(:pz, :s)  =&gt; 0.</span></span>
<span id="cb61-21"><a href="#cb61-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">#(:pz, :px) =&gt; 0.</span></span>
<span id="cb61-22"><a href="#cb61-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">#(:pz, :py) =&gt; 0.</span></span>
<span id="cb61-23"><a href="#cb61-23" aria-hidden="true" tabindex="-1"></a>        (<span class="op">:</span>pz, <span class="op">:</span>pz) <span class="op">=&gt;</span> hopping_ints[<span class="op">:</span>ppπ]</span>
<span id="cb61-24"><a href="#cb61-24" aria-hidden="true" tabindex="-1"></a>        _ <span class="op">=&gt;</span> <span class="fl">0</span>eV</span>
<span id="cb61-25"><a href="#cb61-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb61-26"><a href="#cb61-26" aria-hidden="true" tabindex="-1"></a>    <span class="fu">addhop!</span>(gr2hops, γ, hop.i, hop.j, hop.δ)</span>
<span id="cb61-27"><a href="#cb61-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-28"><a href="#cb61-28" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> <span class="pp">@match</span> orb_types <span class="cf">begin</span></span>
<span id="cb61-29"><a href="#cb61-29" aria-hidden="true" tabindex="-1"></a>        (<span class="op">:</span>s, <span class="op">:</span>s)   <span class="op">=&gt;</span> overlap_vals[<span class="op">:</span>ssσ]</span>
<span id="cb61-30"><a href="#cb61-30" aria-hidden="true" tabindex="-1"></a>        (<span class="op">:</span>s, <span class="op">:</span>px)  <span class="op">=&gt;</span> l <span class="op">*</span> overlap_vals[<span class="op">:</span>spσ]</span>
<span id="cb61-31"><a href="#cb61-31" aria-hidden="true" tabindex="-1"></a>        (<span class="op">:</span>s, <span class="op">:</span>py)  <span class="op">=&gt;</span> m <span class="op">*</span> overlap_vals[<span class="op">:</span>spσ]</span>
<span id="cb61-32"><a href="#cb61-32" aria-hidden="true" tabindex="-1"></a>        <span class="co">#(:s, :pz) =&gt; 0.</span></span>
<span id="cb61-33"><a href="#cb61-33" aria-hidden="true" tabindex="-1"></a>        (<span class="op">:</span>px, <span class="op">:</span>s)  <span class="op">=&gt;</span> l <span class="op">*</span> overlap_vals[<span class="op">:</span>spσ]</span>
<span id="cb61-34"><a href="#cb61-34" aria-hidden="true" tabindex="-1"></a>        (<span class="op">:</span>px, <span class="op">:</span>px) <span class="op">=&gt;</span> l<span class="op">^</span><span class="fl">2</span> <span class="op">*</span> overlap_vals[<span class="op">:</span>ppσ] <span class="op">+</span> (<span class="fl">1</span><span class="op">-</span>l<span class="op">^</span><span class="fl">2</span>) <span class="op">*</span> overlap_vals[<span class="op">:</span>ppπ]</span>
<span id="cb61-35"><a href="#cb61-35" aria-hidden="true" tabindex="-1"></a>        (<span class="op">:</span>px, <span class="op">:</span>py) <span class="op">=&gt;</span> l<span class="op">*</span>m <span class="op">*</span> (overlap_vals[<span class="op">:</span>ppσ] <span class="op">-</span> overlap_vals[<span class="op">:</span>ppπ])</span>
<span id="cb61-36"><a href="#cb61-36" aria-hidden="true" tabindex="-1"></a>        <span class="co">#(:px, :pz) =&gt; 0.</span></span>
<span id="cb61-37"><a href="#cb61-37" aria-hidden="true" tabindex="-1"></a>        (<span class="op">:</span>py, <span class="op">:</span>s)  <span class="op">=&gt;</span> m <span class="op">*</span> overlap_vals[<span class="op">:</span>spσ]</span>
<span id="cb61-38"><a href="#cb61-38" aria-hidden="true" tabindex="-1"></a>        (<span class="op">:</span>py, <span class="op">:</span>px) <span class="op">=&gt;</span> l<span class="op">*</span>m <span class="op">*</span> (overlap_vals[<span class="op">:</span>ppσ] <span class="op">-</span> overlap_vals[<span class="op">:</span>ppπ])</span>
<span id="cb61-39"><a href="#cb61-39" aria-hidden="true" tabindex="-1"></a>        (<span class="op">:</span>py, <span class="op">:</span>py) <span class="op">=&gt;</span> m<span class="op">^</span><span class="fl">2</span> <span class="op">*</span> overlap_vals[<span class="op">:</span>ppσ] <span class="op">+</span> (<span class="fl">1</span><span class="op">-</span>m<span class="op">^</span><span class="fl">2</span>) <span class="op">*</span> overlap_vals[<span class="op">:</span>ppπ]</span>
<span id="cb61-40"><a href="#cb61-40" aria-hidden="true" tabindex="-1"></a>        <span class="co">#(:py, :pz) =&gt; 0.</span></span>
<span id="cb61-41"><a href="#cb61-41" aria-hidden="true" tabindex="-1"></a>        <span class="co">#(:pz, :s)  =&gt; 0.</span></span>
<span id="cb61-42"><a href="#cb61-42" aria-hidden="true" tabindex="-1"></a>        <span class="co">#(:pz, :px) =&gt; 0.</span></span>
<span id="cb61-43"><a href="#cb61-43" aria-hidden="true" tabindex="-1"></a>        <span class="co">#(:pz, :py) =&gt; 0.</span></span>
<span id="cb61-44"><a href="#cb61-44" aria-hidden="true" tabindex="-1"></a>        (<span class="op">:</span>pz, <span class="op">:</span>pz) <span class="op">=&gt;</span> overlap_vals[<span class="op">:</span>ppπ]</span>
<span id="cb61-45"><a href="#cb61-45" aria-hidden="true" tabindex="-1"></a>        _ <span class="op">=&gt;</span> <span class="fl">0</span></span>
<span id="cb61-46"><a href="#cb61-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb61-47"><a href="#cb61-47" aria-hidden="true" tabindex="-1"></a>    <span class="fu">addoverlap!</span>(gr2hops, s, hop.i, hop.j, hop.δ)</span>
<span id="cb61-48"><a href="#cb61-48" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb61-49"><a href="#cb61-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-50"><a href="#cb61-50" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i, orb) <span class="op">∈</span> <span class="fu">enumerate</span>(orbs)</span>
<span id="cb61-51"><a href="#cb61-51" aria-hidden="true" tabindex="-1"></a>    orb_type <span class="op">=</span> orb[<span class="fl">1</span>]</span>
<span id="cb61-52"><a href="#cb61-52" aria-hidden="true" tabindex="-1"></a>    μ <span class="op">=</span> <span class="pp">@match</span> orb_type <span class="cf">begin</span></span>
<span id="cb61-53"><a href="#cb61-53" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span>s <span class="op">=&gt;</span> onsite_es[<span class="op">:</span>s]</span>
<span id="cb61-54"><a href="#cb61-54" aria-hidden="true" tabindex="-1"></a>        _  <span class="op">=&gt;</span> onsite_es[<span class="op">:</span>p]</span>
<span id="cb61-55"><a href="#cb61-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb61-56"><a href="#cb61-56" aria-hidden="true" tabindex="-1"></a>    <span class="fu">addonsite!</span>(gr2hops, μ , i)</span>
<span id="cb61-57"><a href="#cb61-57" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The symmetry arguments creep in here again: almost every value related to the <span class="math inline">\(p_z\)</span> orbitals, whether it’s hopping or overlap, is equal to 0 because the <span class="math inline">\(z\)</span>-distance of all orbitals is equal to 0. The only non-zero contribution is from the <span class="math inline">\(pp\pi\)</span>-terms of <span class="math inline">\(p_z\)</span> orbitals as they are aligned in a plane perpendicular to the <span class="math inline">\(xy\)</span>-directions.</p>
<p>With the parameters done, now I just construct the k-space trajectory, such that we can compare it to the published stuff linked above:</p>
<div class="cell" data-execution_count="59">
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>grks2 <span class="op">=</span> <span class="fu">kpath</span>([</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span>K <span class="op">=&gt;</span> [<span class="fl">1</span><span class="op">/</span><span class="fl">3</span>,<span class="fl">1</span><span class="op">/</span><span class="fl">3</span>],</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span>Γ <span class="op">=&gt;</span> [<span class="fl">0</span>,<span class="fl">0</span>],</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span>M <span class="op">=&gt;</span> [<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>,<span class="fl">0</span>],</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span>K <span class="op">=&gt;</span> [<span class="fl">1</span><span class="op">/</span><span class="fl">3</span>,<span class="fl">1</span><span class="op">/</span><span class="fl">3</span>]</span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>        ], <span class="fl">0.005</span>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>And solve, this time keeping the eigenvalues <em>and</em> eigenvectors (which I normalize):</p>
<div class="cell" data-execution_count="60">
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="fu">gr2tbH</span>(k) <span class="op">=</span> <span class="fu">tbH</span>(k, gr2hops)</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>gr2sols <span class="op">=</span> <span class="fu">gr2tbH</span>.(grks2.path) <span class="op">.|&gt;</span> <span class="fu">x-&gt;eigen</span>(x<span class="op">...</span>)</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>gr2es <span class="op">=</span> [eig.values for eig <span class="op">∈</span> gr2sols]</span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>gr2vecs <span class="op">=</span> [<span class="fu">mapslices</span>(v<span class="op">-&gt;</span>v<span class="op">./</span><span class="fu">norm</span>(v), eig.vectors, dims<span class="op">=</span><span class="fl">1</span>) for eig <span class="op">∈</span> gr2sols];</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>I could just plot the bands the same boring way as before but, because this is the money plot of this part, I’ll get a bit fancier with it.</p>
<p>The elements of the eigenvectors (or rather their squares) tell us how much of each orbital is mixed into the band at a given k-value, so we can tell if a given band has more <span class="math inline">\(2p_{x/y/z}\)</span> or <span class="math inline">\(2s\)</span> character. Because this is not my first rodeo (and I read the above-linked papers), I’ll color-code the bands by three different categories: the redder the band, the more <span class="math inline">\(2s\)</span>-like it is at that momentum, <span class="math inline">\(2p_{x/y}\)</span>-like bands are green and bands with <span class="math inline">\(2p_z\)</span> character will be blue:</p>
<div class="cell" data-execution_count="61">
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>fig_gr2 <span class="op">=</span> <span class="fu">Figure</span>()</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>ax_gr2 <span class="op">=</span> <span class="fu">Axis</span>(fig_gr2)</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>ax_gr2.xticks <span class="op">=</span> ([p.second for p <span class="op">∈</span> grks2.ppoints], </span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>                [<span class="fu">string</span>(p.first) for p <span class="op">∈</span> grks2.ppoints])</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>ax_gr2.yticks <span class="op">=</span> <span class="op">-</span><span class="fl">0.7</span><span class="op">:</span><span class="fl">0.1</span><span class="op">:</span><span class="fl">0.5</span></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>ax_gr2.ylabel <span class="op">=</span> <span class="st">"E [Ha]"</span></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a><span class="fu">xlims!</span>(ax_gr2, (<span class="fl">0</span>, grks2.plength[<span class="kw">end</span>]))</span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a><span class="fu">ylims!</span>(ax_gr2, (<span class="op">-</span><span class="fl">0.75</span>,<span class="fl">0.55</span>))</span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a><span class="fu">hideydecorations!</span>(ax_gr2, ticks<span class="op">=</span><span class="cn">false</span>, ticklabels<span class="op">=</span><span class="cn">false</span>, label<span class="op">=</span><span class="cn">false</span>)</span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n <span class="op">∈</span> <span class="fl">1</span><span class="op">:</span><span class="fu">length</span>(gr2es[<span class="fl">1</span>])</span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="op">∈</span> <span class="fl">1</span><span class="op">:</span><span class="fu">length</span>(grks2.plength)</span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a>    pzc <span class="op">=</span> <span class="fu">abs2</span>.(gr2vecs[i])[<span class="op">:</span>,n] <span class="op">⋅</span> [<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">1</span>.,<span class="fl">1</span>.] <span class="co"># sum contributions from pz orbitals</span></span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a>    sc <span class="op">=</span> <span class="fu">abs2</span>.(gr2vecs[i])[<span class="op">:</span>,n] <span class="op">⋅</span> [<span class="fl">1</span>.,<span class="fl">1</span>.,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>] <span class="co"># sum contributions from s orbitals</span></span>
<span id="cb64-16"><a href="#cb64-16" aria-hidden="true" tabindex="-1"></a>    pxyc <span class="op">=</span> <span class="fu">abs2</span>.(gr2vecs[i])[<span class="op">:</span>,n] <span class="op">⋅</span> [<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">1</span>.,<span class="fl">1</span>.,<span class="fl">1</span>.,<span class="fl">1</span>.,<span class="fl">0</span>,<span class="fl">0</span>] <span class="co"># sum contributions from px/y orbitals</span></span>
<span id="cb64-17"><a href="#cb64-17" aria-hidden="true" tabindex="-1"></a>    <span class="fu">scatter!</span>(grks2.plength[i], gr2es[i][n];</span>
<span id="cb64-18"><a href="#cb64-18" aria-hidden="true" tabindex="-1"></a>            color<span class="op">=</span><span class="fu">RGB</span>(sc,pxyc,pzc), markersize<span class="op">=</span><span class="fl">3</span>)</span>
<span id="cb64-19"><a href="#cb64-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb64-20"><a href="#cb64-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb64-21"><a href="#cb64-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-22"><a href="#cb64-22" aria-hidden="true" tabindex="-1"></a>fig_gr2[<span class="fl">1</span>,<span class="fl">1</span>] <span class="op">=</span> ax_gr2</span>
<span id="cb64-23"><a href="#cb64-23" aria-hidden="true" tabindex="-1"></a><span class="fu">current_figure</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="202">
<p><img src="index_files/figure-html/cell-62-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>And here we are - real, raw, physics. You see that the <span class="math inline">\(2s\)</span> and <span class="math inline">\(2p_{x/y}\)</span> bands do mix, while the <span class="math inline">\(2p_z\)</span> bands stay untouched, which is exactly the <span class="math inline">\(sp^2\)</span> hybridization in action and the reason why you often see graphene discussed only in terms of two orbitals. The electrons fill up the states up to the Fermi level (E = 0) and the only two bands close to that value are the <span class="math inline">\(2p_z\)</span> orbitals, which means that their linear dispersion around the <span class="math inline">\(K\)</span>-point dominates low-energy physics (the usual solid state and condensed matter conditions). Because they don’t interact with the rest, one can pluck them out of the Hamiltonian and deal with just the 2-state system.</p>
<p>The last two small things to discuss are the amount of mixing and the energy asymmetry of the <span class="math inline">\(2p_z\)</span> bands. You see that the states close to the <span class="math inline">\(\Gamma\)</span>-point (lowest momentum) are very symmetric in real space. They either belong to the rotationally symmetric <span class="math inline">\(2s\)</span> band or to the degenerate <span class="math inline">\(2p_{x,y}\)</span> bands that would probably like to form the also symmetric <span class="math inline">\(2p_{m_l = \pm,1}\)</span> orbitals. This is because the highly delocalized low-momentum states feel a mostly uniform background due to their spatial extent. But as the states disperse, the lattice symmetry does its thing and forces the hybridization so that they extend along the space between the atomic cores which minimizes their potential energy.</p>
<p>As for the <span class="math inline">\(2p_z\)</span> orbitals, we didn’t do it entirely right the first time. In the model graphene, we assumed that both states don’t have any structure to them and that they have the same energy. In real graphene that’s not true. The <span class="math inline">\(2p_z\)</span> orbitals have polarity, where the wavefunction is negative at one lobe and positive at the other, which affects the energy of states that are constructed by linear combinations of the <span class="math inline">\(2p_z\)</span> orbitals. Because we’re in a crystal with an infinite amount of atoms, it’s not as intuitively obvious, but the effect at play is very similar to that of the simple splitting into <a href="https://en.wikipedia.org/wiki/Bonding_molecular_orbital">bonding</a> and <a href="https://en.wikipedia.org/wiki/Antibonding_molecular_orbital">anti-bonding</a> orbitals in molecules, where delocalization of the state reduces the energy of the parallel one. The case at hand is, of course, still somewhat artificial because the value of the overlap integral can have an arbitrary sign or magnitude. The real physics that’s driving the electron-hole asymmetry in graphene is much more complicated, but it manifests itself in this simple manner when fit to better data.</p>
<section id="sec-cmpm3-interface" class="level3">
<h3 class="anchored" data-anchor-id="sec-cmpm3-interface">Packing it up</h3>
<p>Everything works, but there’s a lot of boilerplate code involved in getting from the definition of the crystal to plotting the bands. To eliminate the headaches of dealing with multiple structures and functions with arcane signatures, I’ll finish by creating a kind of an <a href="https://en.wikipedia.org/wiki/Interface_(computing)">interface</a>.</p>
<p>The user wants to know how to define a problem and have it solved, maybe plotted. They don’t want to deal with the inner workings of the solution. For that, I define a type called <code>Solution</code> which will hold all the important data, no matter how the solution was acquired (and have accessor functions to retrieve it, in case I change the inner structure of the <code>Solution</code> in the future):</p>
<div class="cell" data-execution_count="62">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Solution</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>    ks<span class="op">::</span><span class="dt">Vector{Union{&lt;:Real, Vector{&lt;:Real}}}</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>    kp<span class="op">::</span><span class="dt">Vector{&lt;:Real}</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>    kl<span class="op">::</span><span class="dt">Vector{Pair{Symbol, &lt;:Real}}</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>    es<span class="op">::</span><span class="dt">Vector{Vector{Real}}</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>    evs<span class="op">::</span><span class="dt">Vector{Matrix{Complex}}</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a><span class="fu">evals</span>(s<span class="op">::</span><span class="dt">Solution</span>) <span class="op">=</span> s.es</span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a><span class="fu">evecs</span>(s<span class="op">::</span><span class="dt">Solution</span>) <span class="op">=</span> s.evs</span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a><span class="fu">kvecs</span>(s<span class="op">::</span><span class="dt">Solution</span>) <span class="op">=</span> s.ks;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>And a function that will give the solution. First, a catch-all method that errors if the problem definition doesn’t yield a solution:</p>
<div class="cell" data-execution_count="63">
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">solve</span>(p)</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> <span class="fu">typeof</span>(p)</span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">ArgumentError</span>(<span class="st">"</span><span class="sc">$</span>t<span class="st"> has no solution implemented."</span>)</span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Then, I’ll conjure a type that determines the problem to be solved. The solution in this case is the tight-binding method. Because <code>Hoppings</code> are relatively free-form in their construction, they have to be generated externally, either with the help of provided helper functions or entirely by hand.</p>
<div class="cell" data-execution_count="64">
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> TightBindingProblem</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>    hops<span class="op">::</span><span class="dt">Hoppings</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>    ks<span class="op">::</span><span class="dt">Vector{Union{&lt;:Real, Vector{&lt;:Real}}}</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>    kp<span class="op">::</span><span class="dt">Vector{&lt;:Real}</span></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>    kl<span class="op">::</span><span class="dt">Vector{Pair{Symbol, &lt;:Real}}</span></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">TightBindingProblem</span>(hops<span class="op">::</span><span class="dt">Hoppings</span>, kpositions<span class="op">::</span><span class="dt">Vector</span>, kstep<span class="op">::</span><span class="dt">Real</span>)</span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> <span class="fu">kpath</span>(kpositions, kstep)</span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">TightBindingProblem</span>(hops, k.path, k.plength, k.ppoints)</span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>And finally, a method of <code>solve</code> that will handle the tight-binding problem.</p>
<div class="cell" data-execution_count="65">
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">solve</span>(p<span class="op">::</span><span class="dt">TightBindingProblem</span>)<span class="op">::</span><span class="dt">Solution</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">h</span>(k) <span class="op">=</span> <span class="fu">tbH</span>(k, p.hops)</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>    sols <span class="op">=</span> <span class="fu">gr2tbH</span>.(p.ks) <span class="op">.|&gt;</span> <span class="fu">x-&gt;eigen</span>(x<span class="op">...</span>)</span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">Solution</span>(</span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>        p.ks,</span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>        p.kp,</span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a>        p.kl,</span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a>        [eig.values for eig <span class="op">∈</span> sols],</span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a>        [<span class="fu">mapslices</span>(v<span class="op">-&gt;</span>v<span class="op">./</span><span class="fu">norm</span>(v), eig.vectors, dims<span class="op">=</span><span class="fl">1</span>) for eig <span class="op">∈</span> sols]</span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>That is technically all that’s needed, but we can provide a convenience function that will plot the bands we just solved for, which will work with any method, as long as it outputs our <code>Solution</code>:</p>
<div class="cell" data-execution_count="66">
<div class="sourceCode cell-code" id="cb69"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">plotSolution</span>(s<span class="op">::</span><span class="dt">Solution</span>)</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>    fig <span class="op">=</span> <span class="fu">Figure</span>()</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>    ax <span class="op">=</span> <span class="fu">Axis</span>(fig)</span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>    ax.xticks <span class="op">=</span> ([p.second for p <span class="op">∈</span> s.kl], </span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>                 [<span class="fu">string</span>(p.first) for p <span class="op">∈</span> s.kl])</span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>    ax.ylabel <span class="op">=</span> <span class="st">"E [Ha]"</span></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">xlims!</span>(ax, (<span class="fl">0</span>, s.kp[<span class="kw">end</span>]))</span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">hideydecorations!</span>(ax, ticks<span class="op">=</span><span class="cn">false</span>, ticklabels<span class="op">=</span><span class="cn">false</span>, label<span class="op">=</span><span class="cn">false</span>)</span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> n <span class="op">∈</span> <span class="fl">1</span><span class="op">:</span><span class="fu">length</span>(s.es[<span class="fl">1</span>])</span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a>        <span class="fu">lines!</span>(s.kp, [<span class="cn">e</span>[n] for <span class="cn">e</span> <span class="op">∈</span> s.es])</span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a>    fig[<span class="fl">1</span>,<span class="fl">1</span>] <span class="op">=</span> ax</span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>And this is how it works in practice. I’ll define the TB problem, using the hoppings I already made before:</p>
<div class="cell" data-execution_count="67">
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>grprob <span class="op">=</span> <span class="fu">TightBindingProblem</span>(gr2hops, [</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">:</span>K <span class="op">=&gt;</span> [<span class="fl">1</span><span class="op">/</span><span class="fl">3</span>,<span class="fl">1</span><span class="op">/</span><span class="fl">3</span>],</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">:</span>Γ <span class="op">=&gt;</span> [<span class="fl">0</span>,<span class="fl">0</span>],</span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">:</span>M <span class="op">=&gt;</span> [<span class="fl">1</span><span class="op">/</span><span class="fl">2</span>,<span class="fl">0</span>],</span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">:</span>K <span class="op">=&gt;</span> [<span class="fl">1</span><span class="op">/</span><span class="fl">3</span>,<span class="fl">1</span><span class="op">/</span><span class="fl">3</span>]</span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a>], <span class="fl">0.005</span>);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Solve it and pipe it straight into the plotting routine:</p>
<div class="cell" data-execution_count="68">
<div class="sourceCode cell-code" id="cb71"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="fu">solve</span>(grprob) <span class="op">|&gt;</span> plotSolution</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a><span class="fu">ylims!</span>(<span class="fu">current_axis</span>(), (<span class="op">-</span><span class="fl">0.75</span>,<span class="fl">0.55</span>))</span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a><span class="fu">current_axis</span>().title<span class="op">=</span><span class="st">"Graphene"</span></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a><span class="fu">current_figure</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="209">
<p><img src="index_files/figure-html/cell-69-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Nice, convenient and, depending on how many hoppings you need, short.</p>
<hr>
<p>And here we are, the very basics of solid state physics are covered. There are a few more single-particle methods that I might cover in the next part, although they are generally more niche and often used just as precursors to many-particle problems, so I might skip straight to interacting systems and delve into actual condensed matter physics.</p>
<p>Between now and the next part of this series, a large part of today’s code (functions and types related to crystals and the solution interfaces and methods) will be put into a library that we’ll then start extending and using. That means this will be the last truly self-contained post, but that is a sacrifice that has to be made.</p>


</section>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>technically, there’s only 219 affine space groups and 230 crystallographic space groups, but we’re getting too deep into this non-sense.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>LPT: a determinant of a matrix is the volume of the parallelepiped spanned by the vectors in the matrix. It’s frequently used for normalization and easy to calculate, so I threw it in.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Ignoring, for the moment, how realistic that is.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>It takes <a href="https://doi.org/10.1103/PhysRev.118.1182">only two coefficients</a> <span class="math inline">\(V_{[111]}\)</span> and <span class="math inline">\(V_{[200]}\)</span> to get good results for aluminum<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p><span class="math inline">\(c\)</span> in the graphene case is, of course, not the speed of light - if you really wanted to interpret it as such, it’s about <a href="https://www.nature.com/articles/nature04233">100 times slower</a>.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
      <div class="nav-footer-center">© Copyright 2023, Tomas Polakovic. Except where otherwise noted, all text and images licensed CC-BY-NC 4.0.</div>
  </div>
</footer>



</body></html>